<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>细水会流长</title>
  
  <subtitle>不积跬步，无以至千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://micsay.com/"/>
  <updated>2020-08-02T06:17:48.846Z</updated>
  <id>https://micsay.com/</id>
  
  <author>
    <name>崔怀祥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue源码解析</title>
    <link href="https://micsay.com/2020/08/01/get-start-on-vue/"/>
    <id>https://micsay.com/2020/08/01/get-start-on-vue/</id>
    <published>2020-08-01T04:48:02.000Z</published>
    <updated>2020-08-02T06:17:48.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>特别声明：本文未经许可禁止转载</p></blockquote><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><ul><li>不能免俗，我也要做Vue源码解析了</li><li>本文基于<code>Vue 2.5.8-beta</code>版本进行分析</li><li>源码讲解的第一行附了源码路径，可供查看，我会在我认为重要的地方加注释</li><li>如果有疑问，可以留言或者关注我公众号并发送消息</li><li>本文通俗易懂，不人云亦云，应该都能看得懂</li></ul><h3 id="Vue-Compiler：编译Vue模版"><a href="#Vue-Compiler：编译Vue模版" class="headerlink" title="Vue Compiler：编译Vue模版"></a>Vue Compiler：编译Vue模版</h3><ul><li>先来看一下，开发者开发时的Vue代码结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;Hello World&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure></li><li>以上代码，经过Vue compiler处理之后，template会变成<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_c(&quot;div&quot;, [_c(&quot;span&quot;, [_vm._v(&quot;Hello World&quot;)])])</span><br></pre></td></tr></table></figure></li><li>其中，_c就是createElement，定义在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;render.js</span><br><span class="line">vm._c &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, false)</span><br></pre></td></tr></table></figure></li><li>看一下Vue compiler入口，可猜出该部分的功能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;compiler&#x2F;index.js</span><br><span class="line">export const createCompiler &#x3D; createCompilerCreator(function baseCompile (</span><br><span class="line">  template: string,</span><br><span class="line">  options: CompilerOptions</span><br><span class="line">): CompiledResult &#123;</span><br><span class="line">  const ast &#x3D; parse(template.trim(), options)</span><br><span class="line">  if (options.optimize !&#x3D;&#x3D; false) &#123;</span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  const code &#x3D; generate(ast, options)</span><br><span class="line">  return &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>输入是模版string，输出是render函数，而这个render函数，将会被Vue-loader使用，将其声明到options中，后面Vue.prototype._render()函数中使用到到options.render(xx)函数，就是由此而来。另外Vue compiler还对某些Vue特性做了处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render &#x3D; function (): VNode &#123;</span><br><span class="line">    const vm: Component &#x3D; this</span><br><span class="line">    const &#123; render, _parentVnode &#125; &#x3D; vm.$options &#x2F;&#x2F; 1. 该render函数就是Vue compiler编译输出的</span><br><span class="line"></span><br><span class="line">    if (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots &#x3D; _parentVnode.data.scopedSlots || emptyObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; set parent vnode. this allows render functions to have access</span><br><span class="line">    &#x2F;&#x2F; to the data on the placeholder node.</span><br><span class="line">    vm.$vnode &#x3D; _parentVnode</span><br><span class="line">    &#x2F;&#x2F; render self</span><br><span class="line">    let vnode</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 2、生成vnode，供后面做VDOM DIFF时使用</span><br><span class="line">      vnode &#x3D; render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">      handleError(e, vm, &#96;render&#96;)</span><br><span class="line">      &#x2F;&#x2F; return error render result,</span><br><span class="line">      &#x2F;&#x2F; or previous vnode to prevent render error causing blank component</span><br><span class="line">      &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          vnode &#x3D; vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          handleError(e, vm, &#96;renderError&#96;)</span><br><span class="line">          vnode &#x3D; vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode &#x3D; vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; return empty vnode in case the render function errored out</span><br><span class="line">    if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; Array.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Multiple root nodes returned from render function. Render function &#39; +</span><br><span class="line">          &#39;should return a single root node.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode &#x3D; createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; set parent</span><br><span class="line">    vnode.parent &#x3D; _parentVnode</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Vue-Instance第一次渲染（总计有12个重要注释）"><a href="#Vue-Instance第一次渲染（总计有12个重要注释）" class="headerlink" title="Vue Instance第一次渲染（总计有12个重要注释）"></a>Vue Instance第一次渲染（总计有12个重要注释）</h3><ul><li>一切要从<code>new Vue(options)</code>开始<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello Vue!&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>其实在<code>new Vue(options)</code>之前，需要先考虑<code>Vue Constructor</code>的初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</span><br><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&#39;Vue is a constructor and should be called with the &#96;new&#96; keyword&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options) &#x2F;&#x2F; 1. new Vue(options)时执行</span><br><span class="line">  &#x2F;&#x2F; _init方法即Vue.prototype._init</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2. 以下方法调用，就是在初始化Vue Constructor，从方法名不难猜出其功能</span><br><span class="line">initMixin(Vue) </span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure></li><li>在<code>this._init(options)</code>方法中，初始化<code>Vue Instance</code>，我们来看看<code>_init</code>方法的定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;init.js</span><br><span class="line">  Vue.prototype._init &#x3D; function (options?: Object) &#123; </span><br><span class="line">    &#x2F;&#x2F; 3. 你可能奇怪javascript怎么会有类型声明，这是prop-types在编译时用到的，</span><br><span class="line">    &#x2F;&#x2F; 编译结束之后，就是纯碎的javascript代码了</span><br><span class="line">    const vm: Component &#x3D; this</span><br><span class="line">    &#x2F;&#x2F; a uid</span><br><span class="line">    vm._uid &#x3D; uid++</span><br><span class="line"></span><br><span class="line">    let startTag, endTag</span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag &#x3D; &#96;vue-perf-start:$&#123;vm._uid&#125;&#96;</span><br><span class="line">      endTag &#x3D; &#96;vue-perf-end:$&#123;vm._uid&#125;&#96;</span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; a flag to avoid this being observed</span><br><span class="line">    vm._isVue &#x3D; true</span><br><span class="line">    &#x2F;&#x2F; merge options</span><br><span class="line">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      &#x2F;&#x2F; optimize internal component instantiation</span><br><span class="line">      &#x2F;&#x2F; since dynamic options merging is pretty slow, and none of the</span><br><span class="line">      &#x2F;&#x2F; internal component options needs special treatment.</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm.$options &#x3D; mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy &#x3D; vm</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; expose real self</span><br><span class="line">    vm._self &#x3D; vm</span><br><span class="line">    &#x2F;&#x2F; 4、下面的以init开头的方法，都是根据options，给vm即this塞必要的属性方便开发时使用</span><br><span class="line">    &#x2F;&#x2F; 以call开头的方法，都是在触发Vue的声明周期</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &#39;beforeCreate&#39;)</span><br><span class="line">    initInjections(vm) &#x2F;&#x2F; resolve injections before data&#x2F;props</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) &#x2F;&#x2F; resolve provide after data&#x2F;props</span><br><span class="line">    callHook(vm, &#39;created&#39;)</span><br><span class="line"></span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name &#x3D; formatComponentName(vm, false)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;vm._name&#125; init&#96;, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el) &#x2F;&#x2F; 5、$mount方法，就是mountComponent方法，定义在 &#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js中</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>执行<code>$mount</code>方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js</span><br><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component, &#x2F;&#x2F; 6、vm即this、即Vue Instance</span><br><span class="line">  el: ?Element, &#x2F;&#x2F; 7、new Vue(options)时传入的el</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el &#x3D; el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render &#x3D; createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !&#x3D;&#x3D; &#39;#&#39;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;You are using the runtime-only build of Vue where the template &#39; +</span><br><span class="line">          &#39;compiler is not available. Either pre-compile the templates into &#39; +</span><br><span class="line">          &#39;render functions, or use the compiler-included build.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Failed to mount component: template or render function not defined.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &#39;beforeMount&#39;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      const name &#x3D; vm._name</span><br><span class="line">      const id &#x3D; vm._uid</span><br><span class="line">      const startTag &#x3D; &#96;vue-perf-start:$&#123;id&#125;&#96;</span><br><span class="line">      const endTag &#x3D; &#96;vue-perf-end:$&#123;id&#125;&#96;</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode &#x3D; vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;name&#125; render&#96;, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;name&#125; patch&#96;, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 8、定义updateComponent方法传给Watcher，</span><br><span class="line">    &#x2F;&#x2F; 使用Watcher去watch options中定义的data，一旦data中的数据发生变动，则触发updateComponent</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">      &#x2F;&#x2F; 9、_render方法即Vue.prototype._render，定义在 &#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;render.js，</span><br><span class="line">      &#x2F;&#x2F; 该方法调用了options中的render方法生成了vnode而vnode是VDOM的基础之一，而options中的render方法，则是在Vue Compile阶段</span><br><span class="line">      &#x2F;&#x2F; 根据开发者定义的Vue Template生成的</span><br><span class="line">      &#x2F;&#x2F; 10、_update方法即Vue.prototype._update，定义在 &#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js，</span><br><span class="line">      该方法主要是执行patch方法，而patch方法第一个参数是preVnode，第二个参数是vnode。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; we set this to vm._watcher inside the watcher&#39;s constructor</span><br><span class="line">  &#x2F;&#x2F; since the watcher&#39;s initial patch may call $forceUpdate (e.g. inside child</span><br><span class="line">  &#x2F;&#x2F; component&#39;s mounted hook), which relies on vm._watcher being already defined</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 11、new Watcher(xxx)时，将会在Watcher Constructor中调用传入的updateComponent方法，</span><br><span class="line">  因此，当new Watcher(xxx)执行完毕，DOM操作已经执行完成，页面已经渲染出来了</span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;  </span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, &#39;beforeUpdate&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true &#x2F;* isRenderWatcher *&#x2F;)</span><br><span class="line">  hydrating &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; manually mounted instance, call mounted on self</span><br><span class="line">  &#x2F;&#x2F; mounted is called for render-created child components in its inserted hook</span><br><span class="line">  if (vm.$vnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">    vm._isMounted &#x3D; true</span><br><span class="line">    callHook(vm, &#39;mounted&#39;) &#x2F;&#x2F; 12、第一次渲染完成，由此可以得出结论，Vue是以组件为单位进行watch的</span><br><span class="line">    &#x2F;&#x2F; 那么，如果合理的对Vue代码进行封装，封装成组件，则有可能有效的减少VDOM DIFF时的节点数量</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Vue-VDOM：通过比对VDOM，计算出所需要的真实DOM操作"><a href="#Vue-VDOM：通过比对VDOM，计算出所需要的真实DOM操作" class="headerlink" title="Vue VDOM：通过比对VDOM，计算出所需要的真实DOM操作"></a>Vue VDOM：通过比对VDOM，计算出所需要的真实DOM操作</h3><blockquote><p>VDOM其实是一个定义，是为了与真实DOM相区分而起的名字，不要被吓到，说白了，其实就是用JavaScript的Object（没错就是Vnode）为节点，构成的一棵树，每个节点上有parent、children以及其他信息，这棵树尽可能的与真实的DOM树相匹配，在数据被更新时，生成新VDOM Tree，与旧的VDOM Tree相比对，通过DIFF算法，比对出，需要怎么样操作DOM，才能正确更新</p></blockquote><ul><li>既然Vnode是基础，先看一下Vnode的数据结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;vnode.js</span><br><span class="line">export default class VNode &#123;</span><br><span class="line">  tag: string | void; &#x2F;&#x2F; 1、如vue-compoment-keep-alive</span><br><span class="line">  data: VNodeData | void; &#x2F;&#x2F; 2、patch运行时用到的数据，比如hooks，keepAlive </span><br><span class="line">  children: ?Array&lt;VNode&gt;;</span><br><span class="line">  text: string | void;</span><br><span class="line">  elm: Node | void; &#x2F;&#x2F; 3、真实的DOM节点</span><br><span class="line">  ns: string | void;</span><br><span class="line">  context: Component | void; &#x2F;&#x2F; rendered in this component&#39;s scope</span><br><span class="line">  key: string | number | void;</span><br><span class="line">  componentOptions: VNodeComponentOptions | void; &#x2F;&#x2F; 4、组件的options</span><br><span class="line">  componentInstance: Component | void; &#x2F;&#x2F; component instance &#x2F;&#x2F; 5、组件new完之后的Vue Instance</span><br><span class="line">  parent: VNode | void; &#x2F;&#x2F; component placeholder node</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; strictly internal</span><br><span class="line">  raw: boolean; &#x2F;&#x2F; contains raw HTML? (server only)</span><br><span class="line">  isStatic: boolean; &#x2F;&#x2F; hoisted static node</span><br><span class="line">  isRootInsert: boolean; &#x2F;&#x2F; necessary for enter transition check</span><br><span class="line">  isComment: boolean; &#x2F;&#x2F; empty comment placeholder?</span><br><span class="line">  isCloned: boolean; &#x2F;&#x2F; is a cloned node?</span><br><span class="line">  isOnce: boolean; &#x2F;&#x2F; is a v-once node?</span><br><span class="line">  asyncFactory: Function | void; &#x2F;&#x2F; async component factory function</span><br><span class="line">  asyncMeta: Object | void;</span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  ssrContext: Object | void;</span><br><span class="line">  fnContext: Component | void; &#x2F;&#x2F; real context vm for functional nodes</span><br><span class="line">  fnOptions: ?ComponentOptions; &#x2F;&#x2F; for SSR caching</span><br><span class="line">  devtoolsMeta: ?Object; &#x2F;&#x2F; used to store functional render context for devtools</span><br><span class="line">  fnScopeId: ?string; &#x2F;&#x2F; functional scope id support</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.tag &#x3D; tag</span><br><span class="line">    this.data &#x3D; data</span><br><span class="line">    this.children &#x3D; children</span><br><span class="line">    this.text &#x3D; text</span><br><span class="line">    this.elm &#x3D; elm</span><br><span class="line">    this.ns &#x3D; undefined</span><br><span class="line">    this.context &#x3D; context</span><br><span class="line">    this.fnContext &#x3D; undefined</span><br><span class="line">    this.fnOptions &#x3D; undefined</span><br><span class="line">    this.fnScopeId &#x3D; undefined</span><br><span class="line">    this.key &#x3D; data &amp;&amp; data.key</span><br><span class="line">    this.componentOptions &#x3D; componentOptions</span><br><span class="line">    this.componentInstance &#x3D; undefined</span><br><span class="line">    this.parent &#x3D; undefined</span><br><span class="line">    this.raw &#x3D; false</span><br><span class="line">    this.isStatic &#x3D; false</span><br><span class="line">    this.isRootInsert &#x3D; true</span><br><span class="line">    this.isComment &#x3D; false</span><br><span class="line">    this.isCloned &#x3D; false</span><br><span class="line">    this.isOnce &#x3D; false</span><br><span class="line">    this.asyncFactory &#x3D; asyncFactory</span><br><span class="line">    this.asyncMeta &#x3D; undefined</span><br><span class="line">    this.isAsyncPlaceholder &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; DEPRECATED: alias for componentInstance for backwards compat.</span><br><span class="line">  &#x2F;* istanbul ignore next *&#x2F;</span><br><span class="line">  get child (): Component | void &#123;</span><br><span class="line">    return this.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>先解释一下Patch，Patch是Vue VDOM部分中的一个函数，该函数就是<code>Vue.prototype.__patch__</code>，而该函数其实就是在做DIFF，输入是oldVnode、vnode，输出是DIFF后，需要对真实DOM节点所做对DOM操作，比如createElemennt、insertBefore、appendChild等等，而驱动该函数运行的，是Watcher，而Watcher观察的，是data。因此，开发者只需要改变Vue options中的data，就能完成想要的更新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;patch.js</span><br><span class="line">function patch (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    &#x2F;&#x2F; 6、输入参数是oldVnode、vnode，就是对oldVnode和vnode做DIFF</span><br><span class="line">    if (isUndef(vnode)) &#123;</span><br><span class="line">      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let isInitialPatch &#x3D; false</span><br><span class="line">    const insertedVnodeQueue &#x3D; []</span><br><span class="line"></span><br><span class="line">    if (isUndef(oldVnode)) &#123;</span><br><span class="line">      &#x2F;&#x2F; empty mount (likely as component), create new root element</span><br><span class="line">      isInitialPatch &#x3D; true</span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const isRealElement &#x3D; isDef(oldVnode.nodeType)</span><br><span class="line">      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        &#x2F;&#x2F; patch existing root node</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 7、开始做DIFF</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (isRealElement) &#123;</span><br><span class="line">          &#x2F;&#x2F; mounting to a real element</span><br><span class="line">          &#x2F;&#x2F; check if this is server-rendered content and if we can perform</span><br><span class="line">          &#x2F;&#x2F; a successful hydration.</span><br><span class="line">          if (oldVnode.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating &#x3D; true</span><br><span class="line">          &#125;</span><br><span class="line">          if (isTrue(hydrating)) &#123;</span><br><span class="line">            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, true)</span><br><span class="line">              return oldVnode</span><br><span class="line">            &#125; else if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                &#39;The client-side rendered virtual DOM tree is not matching &#39; +</span><br><span class="line">                &#39;server-rendered content. This is likely caused by incorrect &#39; +</span><br><span class="line">                &#39;HTML markup, for example nesting block-level elements inside &#39; +</span><br><span class="line">                &#39;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#39; +</span><br><span class="line">                &#39;full client-side render.&#39;</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; either not server-rendered, or hydration failed.</span><br><span class="line">          &#x2F;&#x2F; create an empty node and replace it</span><br><span class="line">          oldVnode &#x3D; emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; replacing existing element</span><br><span class="line">        const oldElm &#x3D; oldVnode.elm</span><br><span class="line">        const parentElm &#x3D; nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; create new node</span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          &#x2F;&#x2F; extremely rare edge case: do not insert if old element is in a</span><br><span class="line">          &#x2F;&#x2F; leaving transition. Only happens when combining transition +</span><br><span class="line">          &#x2F;&#x2F; keep-alive + HOCs. (#4590)</span><br><span class="line">          oldElm._leaveCb ? null : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; update parent placeholder node element, recursively</span><br><span class="line">        if (isDef(vnode.parent)) &#123;</span><br><span class="line">          let ancestor &#x3D; vnode.parent</span><br><span class="line">          const patchable &#x3D; isPatchable(vnode)</span><br><span class="line">          while (ancestor) &#123;</span><br><span class="line">            for (let i &#x3D; 0; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm &#x3D; vnode.elm</span><br><span class="line">            if (patchable) &#123;</span><br><span class="line">              for (let i &#x3D; 0; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              &#x2F;&#x2F; #6513</span><br><span class="line">              &#x2F;&#x2F; invoke insert hooks that may have been merged by create hooks.</span><br><span class="line">              &#x2F;&#x2F; e.g. for directives that uses the &quot;inserted&quot; hook.</span><br><span class="line">              const insert &#x3D; ancestor.data.hook.insert</span><br><span class="line">              if (insert.merged) &#123;</span><br><span class="line">                &#x2F;&#x2F; start at index 1 to avoid re-invoking component mounted hook</span><br><span class="line">                for (let i &#x3D; 1; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor &#x3D; ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; destroy old node</span><br><span class="line">        if (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes(parentElm, [oldVnode], 0, 0)</span><br><span class="line">        &#125; else if (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    return vnode.elm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>我们来看一下patchVnode函数。整个VDOM树，每个节点都有parent和children，而patchVnode其实在做的是：比对oldVnode’s children与vnode’s children<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">function patchVnode (</span><br><span class="line">    oldVnode,</span><br><span class="line">    vnode,</span><br><span class="line">    insertedVnodeQueue,</span><br><span class="line">    ownerArray,</span><br><span class="line">    index,</span><br><span class="line">    removeOnly</span><br><span class="line">  ) &#123;</span><br><span class="line">    if (oldVnode &#x3D;&#x3D;&#x3D; vnode) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">      &#x2F;&#x2F; clone reused vnode</span><br><span class="line">      vnode &#x3D; ownerArray[index] &#x3D; cloneVNode(vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const elm &#x3D; vnode.elm &#x3D; oldVnode.elm</span><br><span class="line"></span><br><span class="line">    if (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">      if (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode.isAsyncPlaceholder &#x3D; true</span><br><span class="line">      &#125;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; reuse element for static trees.</span><br><span class="line">    &#x2F;&#x2F; note we only do this if the vnode is cloned -</span><br><span class="line">    &#x2F;&#x2F; if the new node is not cloned it means the render functions have been</span><br><span class="line">    &#x2F;&#x2F; reset by the hot-reload-api and we need to do a proper re-render.</span><br><span class="line">    if (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">      isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">      vnode.key &#x3D;&#x3D;&#x3D; oldVnode.key &amp;&amp;</span><br><span class="line">      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.componentInstance &#x3D; oldVnode.componentInstance</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let i</span><br><span class="line">    const data &#x3D; vnode.data</span><br><span class="line">    if (isDef(data) &amp;&amp; isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const oldCh &#x3D; oldVnode.children</span><br><span class="line">    const ch &#x3D; vnode.children</span><br><span class="line">    if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      for (i &#x3D; 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isUndef(vnode.text)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 8、如果children都存在，则比对children</span><br><span class="line">      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; else if (isDef(ch)) &#123; &#x2F;&#x2F; 9、如果只有vnode上存在children，则这些children都需被add</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          checkDuplicateKeys(ch)</span><br><span class="line">        &#125;</span><br><span class="line">        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)</span><br><span class="line">        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">      &#125; else if (isDef(oldCh)) &#123; &#x2F;&#x2F; 10、如果只有oldVnode上存在children，则这些children都需被删除</span><br><span class="line">        removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">      &#125; else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, &#39;&#39;) &#x2F;&#x2F; 11、针对text 节点做单独处理</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123; &#x2F;&#x2F; 12、针对text节点做单独处理</span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isDef(data)) &#123;</span><br><span class="line">      if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>再看一下updateChildren函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;patch.js</span><br><span class="line">  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    let oldStartIdx &#x3D; 0</span><br><span class="line">    let newStartIdx &#x3D; 0</span><br><span class="line">    let oldEndIdx &#x3D; oldCh.length - 1</span><br><span class="line">    let oldStartVnode &#x3D; oldCh[0]</span><br><span class="line">    let oldEndVnode &#x3D; oldCh[oldEndIdx]</span><br><span class="line">    let newEndIdx &#x3D; newCh.length - 1</span><br><span class="line">    let newStartVnode &#x3D; newCh[0]</span><br><span class="line">    let newEndVnode &#x3D; newCh[newEndIdx]</span><br><span class="line">    let oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">    &#x2F;&#x2F; to ensure removed elements stay in correct relative positions</span><br><span class="line">    &#x2F;&#x2F; during leaving transitions</span><br><span class="line">    const canMove &#x3D; !removeOnly</span><br><span class="line"></span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) &#123;</span><br><span class="line">      if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode &#x3D; oldCh[++oldStartIdx] &#x2F;&#x2F; Vnode has been moved left</span><br><span class="line">      &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode &#x3D; oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode &#x3D; newCh[--newEndIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; &#x2F;&#x2F; Vnode moved right</span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode &#x3D; oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode &#x3D; newCh[--newEndIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; &#x2F;&#x2F; Vnode moved left</span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (isUndef(oldKeyToIdx)) oldKeyToIdx &#x3D; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld &#x3D; isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        if (isUndef(idxInOld)) &#123; &#x2F;&#x2F; New element</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          vnodeToMove &#x3D; oldCh[idxInOld]</span><br><span class="line">          if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] &#x3D; undefined</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; same key but different element. treat as new element</span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm &#x3D; isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-Watcher：相当于大管家，运行时，触发各处的调用"><a href="#Vue-Watcher：相当于大管家，运行时，触发各处的调用" class="headerlink" title="Vue Watcher：相当于大管家，运行时，触发各处的调用"></a>Vue Watcher：相当于大管家，运行时，触发各处的调用</h3>xxx</li></ul><h3 id="Platfrom相关：支撑起web、weex"><a href="#Platfrom相关：支撑起web、weex" class="headerlink" title="Platfrom相关：支撑起web、weex"></a>Platfrom相关：支撑起web、weex</h3><p>xxx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;特别声明：本文未经许可禁止转载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不能免俗，我也要做Vue源码
      
    
    </summary>
    
    
      <category term="前端" scheme="https://micsay.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://micsay.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>VS Code源码解析</title>
    <link href="https://micsay.com/2020/01/08/get-start-on-vscode/"/>
    <id>https://micsay.com/2020/01/08/get-start-on-vscode/</id>
    <published>2020-01-08T15:20:46.000Z</published>
    <updated>2020-08-01T04:44:17.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>特别声明：本文未经许可禁止转载</p></blockquote><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><ul><li><code>VS Code</code>是微软在<code>Electron</code>的基础上使用TypeScript开发的</li><li>本文是基于VS Code 1.36.0版本的基础上分析的</li><li>本文重点解析VS Code工程中，我认为值得学习的地方</li><li>如有问题，可以留言</li></ul><h3 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h3><p>要讲<code>Electron</code>，必须先说<code>Chromium</code>。<code>Chromium</code>使用了多进程架构，分为<code>Browser Process</code>和<code>Render Process</code>，<code>Render Process</code>使用<code>Blink</code>和<code>V8</code>，<code>Blink</code>用于计算布局，<code>V8</code>用于运行<code>JavaScript</code>代码，真正渲染到屏幕上一个一个的像素，是在<code>Browser Process</code>完成的，<code>Browser Process</code>和<code>Render Process</code>通过<code>IPC进程通信</code>（使用Mojo），<code>Browser Process</code>可以保证安全（用于渲染到屏幕，管理Cookie、Storage、网络请求等），而<code>Render Process</code>是在沙箱里面运行的。</p><h3 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h3><p><code>Electron</code>在<code>Chromuim</code>基础上，给<code>Browser Process</code>和<code>Render Process</code>都加进了<code>Node Environment</code>，这样，带来了<code>Node</code>开发者，带来了丰富的NPM包，并且，不论是在<code>Browser Process</code>还是<code>Render Process</code>，都能直接调用<code>Node API</code>，从而获得Native能力。同时，<code>Electron</code>还给<code>Browser Process</code>和<code>Render Process</code>加进了<code>Electron API</code>，为开发者提供<code>Browser Process</code>和<code>Render Process</code>的IPC通信API，以及提供一些必要的功能。<br>以下用主进程表示Browser Process，用渲染进程表示Render Process</p><h3 id="为方便后文理解，先讲一下VS-Code初始化过程"><a href="#为方便后文理解，先讲一下VS-Code初始化过程" class="headerlink" title="为方便后文理解，先讲一下VS Code初始化过程"></a>为方便后文理解，先讲一下VS Code初始化过程</h3><blockquote><p>为方便起见，文件名不加后缀，比如<code>src/main</code>实际为<code>src/main.js</code>，而<code>src/vs/code/electron-main/main</code>实际为<code>src/vs/code/electron-main/main.ts</code></p></blockquote><ul><li>Electron根据根目录下package.json文件中的main字段，在主进程加载<code>src/main</code>，处理本地语言配置以及<code>process.env</code></li><li>加载<code>src/vs/code/electron-main/main</code>，实例化<code>CodeMain</code>类，调用该类中的<code>main()</code>方法，创建主进程中外层的<code>InstantiationService</code>,并实例化<code>CodeApplication</code>类，调用该类中的<code>startup()</code>方法<blockquote><p><code>InstantiationService</code>用于实例化其他类，使得其他类在主进程或者渲染进程中，在保持单例的同时又能很方便的作为构造器参数传入，这个类是VS Code工程中实现依赖注入的重要部分</p></blockquote></li><li>在<code>CodeApplication</code>类的<code>startup()</code>方法中，再次创建<code>InstantiationService</code>，该<code>InstantiationService</code>是外层<code>InstantiationService</code>的<code>child</code>，并且如果某个类的实例在当前窗口的<code>InstantiationService</code>中找不到时，会去外层的<code>InstantiationService</code>中查找，然后实例化各个<code>Service</code>类，并最终在<code>src/vs/code/electron-main/window</code>中调用<code>new BrowserWindow(options)</code>，打开窗口，携带处理完毕的配置参数加载渲染进程的代码<code>src/vs/code/electron-browser/workbench/workbench</code></li><li>加载<code>src/vs/workbench/electron-browser/main</code>，实例化渲染进程各个<code>Service</code>类放入<code>serviceCollection</code>，然后用<code>serviceCollection</code>去实例化渲染进程的<code>InstantiationService</code></li><li>加载后续代码，用TypeScript操作DOM，计算Layout，生成页面</li></ul><h3 id="用Service划分各个功能的界线"><a href="#用Service划分各个功能的界线" class="headerlink" title="用Service划分各个功能的界线"></a>用Service划分各个功能的界线</h3><p><code>VS Code</code>中有许多<code>Service</code>，有的位于主进程，有的位于渲染进程，有的只在主进程使用，有的只在渲染进程使用，有的在主进程中定义逻辑，在渲染进程中通过Electron提供的IPC建立Proxy使用（对于<code>Service</code>使用者来说无感知），<code>Service</code>位于<code>src/vs/platform</code>目录，主要有<code>IInstantiationService</code>,<code>IEnvironmentService</code>,<code>IFileService</code>,<code>ILayoutService</code>,<code>INotificationService</code>,<code>IOpenerService</code>,<code>IStorageService</code>,<code>IWindowsService</code>,<code>IWindowsMainService</code>,<code>IWorkspacesService</code>,<code>IWorkspacesMainService</code>等</p><h4 id="依赖注入Dependency-Injection"><a href="#依赖注入Dependency-Injection" class="headerlink" title="依赖注入Dependency Injection"></a>依赖注入Dependency Injection</h4><p>关于依赖注入的整体介绍，VS Code wiki已经讲的很清楚了:</p><blockquote><p>The code is organized around services of which most are defined in the <code>platform</code> layer. Services get to its clients via <code>constructor injection</code>.<br>A service definition is two parts: (1) the interface of a service, and (2) a service identifier - the latter is required because TypeScript doesn’t use nominal but structural typing. A service identifier is a decoration (as proposed for ES7) and should have the same name as the service interface.<br>Declaring a service dependency happens by adding a corresponding decoration to a constructor argument. In the snippet below <code>@IModelService</code> is the service identifier decoration and <code>IModelService</code> is the (optional) type annotation for this argument. When a dependency is optional, use the <code>@optional</code> decoration otherwise the instantiation service throws an error.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Client &#123;</span><br><span class="line">  constructor(</span><br><span class="line">    @IModelService modelService: IModelService, </span><br><span class="line">    @optional(IEditorService) editorService: IEditorService</span><br><span class="line">  ) &#123;</span><br><span class="line">    &#x2F;&#x2F; use services</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Use the instantiation service to create instances for service consumers, like so <code>instantiationService.createInstance(Client)</code>. Usually, this is done for you when being registered as a contribution, like a Viewlet or Language.</p></blockquote><p>下面从代码角度说明一下：</p><ul><li>使用<code>decoration</code>（注解）将依赖以变量的形式存到<code>Class</code>上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;vs&#x2F;platform&#x2F;instantiation&#x2F;common&#x2F;instantiation.ts</span><br><span class="line">export function createDecorator&lt;T&gt;(serviceId: string): ServiceIdentifier&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">if (_util.serviceIds.has(serviceId)) &#123;</span><br><span class="line">return _util.serviceIds.get(serviceId)!;</span><br><span class="line">&#125;</span><br><span class="line">    &#x2F;&#x2F;根据TypeScript的规定，实现注解函数</span><br><span class="line">const id &#x3D; &lt;any&gt;function (target: Function, key: string, index: number): any &#123;</span><br><span class="line">if (arguments.length !&#x3D;&#x3D; 3) &#123;</span><br><span class="line">throw new Error(&#39;@IServiceName-decorator can only be used to decorate a parameter&#39;);</span><br><span class="line">&#125;</span><br><span class="line">storeServiceDependency(id, target, index, false);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">id.toString &#x3D; () &#x3D;&gt; serviceId;</span><br><span class="line"></span><br><span class="line">_util.serviceIds.set(serviceId, id);</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function storeServiceDependency(id: Function, target: Function, index: number, optional: boolean): void &#123;</span><br><span class="line">    &#x2F;&#x2F; 在运行时，将注解保存到target（Class），方便之后计算graph</span><br><span class="line">if (target[_util.DI_TARGET] &#x3D;&#x3D;&#x3D; target) &#123;</span><br><span class="line">target[_util.DI_DEPENDENCIES].push(&#123; id, index, optional &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">target[_util.DI_DEPENDENCIES] &#x3D; [&#123; id, index, optional &#125;];</span><br><span class="line">target[_util.DI_TARGET] &#x3D; target;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>根据已有信息计算依赖，构造有向图</li><li>找出出度为0的节点，并从这些节点开始，用<code>instantiationService.createInstance(Client)</code>初始化实例<pre class=mermaid>graph LR;  Class-A-->Dependence-Class-B;  Dependence-Class-B-->Dependence-Class-C;  Class-A-->Dependence-Class-D;  Dependence-Class-D-->Dependence-Class-E;  Dependence-Class-D-->Dependence-Class-F;</pre><blockquote><p>其中，Class-A为当前需要实例化的类，graph生成完毕之后，根据规则，先实例化Dependence-Class-C、Dependence-Class-E、Dependence-Class-F，再实例化Dependence-Class-B、Dependence-Class-D，最后才实例化Class-A</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;vs&#x2F;platform&#x2F;instantiation&#x2F;common&#x2F;instantiationService.ts</span><br><span class="line">private _createAndCacheServiceInstance&lt;T&gt;(id: ServiceIdentifier&lt;T&gt;, desc: SyncDescriptor&lt;T&gt;, _trace: Trace): T &#123;</span><br><span class="line">type Triple &#x3D; &#123; id: ServiceIdentifier&lt;any&gt;, desc: SyncDescriptor&lt;any&gt;, _trace: Trace &#125;;</span><br><span class="line">        &#x2F;&#x2F; 有向图，保存出度和入度</span><br><span class="line">const graph &#x3D; new Graph&lt;Triple&gt;(data &#x3D;&gt; data.id.toString());</span><br><span class="line"></span><br><span class="line">function throwCycleError() &#123;</span><br><span class="line">const err &#x3D; new Error(&#39;[createInstance] cyclic dependency between services&#39;);</span><br><span class="line">err.message &#x3D; graph.toString();</span><br><span class="line">throw err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let count &#x3D; 0;</span><br><span class="line">const stack &#x3D; [&#123; id, desc, _trace &#125;];</span><br><span class="line">while (stack.length) &#123;</span><br><span class="line">const item &#x3D; stack.pop()!;</span><br><span class="line">graph.lookupOrInsertNode(item);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO@joh use the graph to find a cycle</span><br><span class="line">&#x2F;&#x2F; a weak heuristic for cycle checks</span><br><span class="line">if (count++ &gt; 100) &#123;</span><br><span class="line">throwCycleError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; check all dependencies for existence and if they need to be created first</span><br><span class="line">let dependencies &#x3D; _util.getServiceDependencies(item.desc.ctor);</span><br><span class="line">for (let dependency of dependencies) &#123;</span><br><span class="line"></span><br><span class="line">let instanceOrDesc &#x3D; this._getServiceInstanceOrDescriptor(dependency.id);</span><br><span class="line">if (!instanceOrDesc &amp;&amp; !dependency.optional) &#123;</span><br><span class="line">console.warn(&#96;[createInstance] $&#123;id&#125; depends on $&#123;dependency.id&#125; which is NOT registered.&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (instanceOrDesc instanceof SyncDescriptor) &#123;</span><br><span class="line">const d &#x3D; &#123; id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) &#125;;</span><br><span class="line">                    &#x2F;&#x2F; 从item节点指向d节点</span><br><span class="line">graph.insertEdge(item, d);</span><br><span class="line">stack.push(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找出出度为0的节点</span><br><span class="line">let roots &#x3D; graph.roots();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if there is no more roots but still</span><br><span class="line">&#x2F;&#x2F; nodes in the graph we have a cycle</span><br><span class="line">if (roots.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">if (!graph.isEmpty()) &#123;</span><br><span class="line">throwCycleError();</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let &#123; data &#125; of roots) &#123;</span><br><span class="line">&#x2F;&#x2F; create instance and overwrite the service collections</span><br><span class="line">const instance &#x3D; this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);</span><br><span class="line">this._setServiceInstance(data.id, instance);</span><br><span class="line">graph.removeNode(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &lt;T&gt;this._getServiceInstanceOrDescriptor(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>值得说明的是，实例化是支持懒加载的，懒加载使用代理模式，懒加载的实现原理如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private _createServiceInstance&lt;T&gt;(ctor: any, args: any[] &#x3D; [], _supportsDelayedInstantiation: boolean, _trace: Trace): T &#123;</span><br><span class="line">if (!_supportsDelayedInstantiation || !_canUseProxy) &#123;</span><br><span class="line">&#x2F;&#x2F; eager instantiation or no support JS proxies (e.g. IE11)</span><br><span class="line">return this._createInstance(ctor, args, _trace);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; Return a proxy object that&#39;s backed by an idle value. That</span><br><span class="line">&#x2F;&#x2F; strategy is to instantiate services in our idle time or when actually</span><br><span class="line">&#x2F;&#x2F; needed but not when injected into a consumer</span><br><span class="line">const idle &#x3D; new IdleValue(() &#x3D;&gt; this._createInstance&lt;T&gt;(ctor, args, _trace));</span><br><span class="line">return &lt;T&gt;new Proxy(Object.create(null), &#123;</span><br><span class="line">get(_target: T, prop: PropertyKey): any &#123;</span><br><span class="line">return idle.getValue()[prop];</span><br><span class="line">&#125;,</span><br><span class="line">set(_target: T, p: PropertyKey, value: any): boolean &#123;</span><br><span class="line">idle.getValue()[p] &#x3D; value;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Part"><a href="#Part" class="headerlink" title="Part"></a>Part</h3><p>打开VS Code并新建一个窗口（默认配置下），可以将窗口分成几大部分：</p><ul><li>TitleBarPart，位于顶部</li><li>ActivityBarPart，位于最左侧，大部分由Icon构成</li><li>SideBarPart，紧贴ActiviyBarPart右侧</li><li>EditorPart，编辑器</li><li>PanelPart，位于编辑器下面，由Terminal等构成</li><li>StatusBarPart，位于最下面，显示状态、分支等<br>可见，VS Code视图由Part构成。<code>Part</code>是VS Code工程中的一个基础类，定义了许多抽象方法，其中，<code>protected createContentArea(parent: HTMLElement, options?: object): HTMLElement | null</code>方法，使用TypeScript操作DOM来用来定义视图</li></ul><h4 id="Part之用TypeScript操作DOM"><a href="#Part之用TypeScript操作DOM" class="headerlink" title="Part之用TypeScript操作DOM"></a>Part之用TypeScript操作DOM</h4><p>在<code>src/vs/base/browser/ui</code>目录下，定义了许多基础的组件，比如<code>SelectBox</code>,用<code>dom.append(container, $(&#39;.option-text&#39;));</code>形式和CSS，定义界面。</p><h3 id="Command机制"><a href="#Command机制" class="headerlink" title="Command机制"></a>Command机制</h3><p>Command可以说是VS Code定义的另一个非常好用的概念。他可以让用户通过<code>Shift+Command+P</code>选择Command然后执行，并且赋予了<code>VS Code Extension</code>扩展Command的能力。Command支持插件进程和VS Code进程相互调用。</p><h3 id="Extension（插件）机制"><a href="#Extension（插件）机制" class="headerlink" title="Extension（插件）机制"></a>Extension（插件）机制</h3><p>软件开发中的开闭原则：开放扩展，关闭修改。Extension便是开闭原则的一个很好的实现。Chrome有插件，Cocos有插件，Hexo有插件，Webpack有插件，Gulp有插件，VS Code也有插件</p><p>VS Code内置插件在<code>extension</code>目录下，内置插件分成两种，一种是本地内置插件，另一种是打包是从Extension Markets下载的内置插件，插件开发文档<a href="https://code.visualstudio.com/api" target="_blank" rel="noopener">点这</a>。从插件大类来看，也可以分成两种，一种是<code>Normal Extension</code>，可以使用VS Code API，另一种是<code>Debugger Extension</code>，用于运行Debug Adapter。</p><h3 id="Gulp编译打包"><a href="#Gulp编译打包" class="headerlink" title="Gulp编译打包"></a>Gulp编译打包</h3><p>Gulp官方介绍如下：</p><blockquote><ul><li>Automation - gulp is a toolkit that helps you automate painful or time-consuming tasks in your development workflow.</li><li>Platform-agnostic - Integrations are built into all major IDEs and people are using gulp with PHP, .NET, Node.js, Java, and other platforms.</li><li>Strong Ecosystem - Use npm modules to do anything you want + over 2000 curated plugins for streaming file transformations</li><li>Simple - By providing only a minimal API surface, gulp is easy to learn and simple to use</li></ul></blockquote><p>VS Code打包脚本位于<code>build</code>目录下，在执行<code>gulp watch</code>之后，gulp会首先加载根目录的<code>gulpfile.js</code>文件，进而加载<code>build</code>目录下一系列<code>gulp.*.js</code>文件，<code>build/gulp.*.js</code>文件中定义了许多<code>gulp task</code>，各个task可以相互依赖。如果想运行VS Code，可以参考[官方文档](<a href="https://github.com/microsoft/VS" target="_blank" rel="noopener">https://github.com/microsoft/VS</a> Code/wiki/How-to-Contribute)。</p><h3 id="VS-Code调试架构"><a href="#VS-Code调试架构" class="headerlink" title="VS Code调试架构"></a>VS Code调试架构</h3><p>VS Code可以调试<code>javascript</code>、<code>python</code>、<code>php</code>、<code>c</code>各种语言，而实现这些调试等基础就是<code>DAP</code>协议，官方对<code>DAP</code>的图示如下：</p><p><img src="/images/debug-arch1.png" alt="dap"></p><p>VS Code 定义了一种抽象的协议即DAP，并实现了一种通用的调试UI，VS Code使用该协议与各种语言的调试进程通信，但是，各种语言不会实现DAP协议，因此，需要一个Adapter，即<code>Debug Adapter（DA）</code>，DA运行在一个单独的进程里面，与调试进程通信。<br>如果你想调试某种语言，首先，需要先实现该语言的<code>Debug Adapter</code>并以<code>Debugger Extension</code>的形式，安装到VS Code上，关于如何实现，你可以查看<a href="https://code.visualstudio.com/api/extension-guides/debugger-extension" target="_blank" rel="noopener">官方文档</a>。当然，大部分语言的<code>Debug Adapter</code>都已经被实现，你可以直接使用。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle</a><br><a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/decorators.html</a><br><a href="https://github.com/microsoft/vscode/wiki/Source-Code-Organization" target="_blank" rel="noopener">https://github.com/microsoft/vscode/wiki/Source-Code-Organization</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a><br><a href="https://code.visualstudio.com/api/extension-guides/debugger-extension" target="_blank" rel="noopener">https://code.visualstudio.com/api/extension-guides/debugger-extension</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;特别声明：本文未经许可禁止转载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VS Code&lt;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://micsay.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://micsay.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>怎样选择并学习一个开源项目</title>
    <link href="https://micsay.com/2020/01/07/how-to-learn-a-project/"/>
    <id>https://micsay.com/2020/01/07/how-to-learn-a-project/</id>
    <published>2020-01-07T15:22:23.000Z</published>
    <updated>2020-08-01T05:05:31.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="怎样选择一个开源项目去学习"><a href="#怎样选择一个开源项目去学习" class="headerlink" title="怎样选择一个开源项目去学习"></a>怎样选择一个开源项目去学习</h3><ul><li>文档要丰富，包括user guide，document api，从clone到运行环境配置，debug</li><li>有测试用例，如果一个项目没有测试用例，那么这个项目最好不要去看</li><li>blog post丰富</li><li>有需求，能用得上，如果用不上，很快就忘记了</li></ul><h3 id="怎样学习一个开源项目"><a href="#怎样学习一个开源项目" class="headerlink" title="怎样学习一个开源项目"></a>怎样学习一个开源项目</h3><ul><li>首先，网速要快。由于众所周知的原因，我们需要一个工具，跨过山和大海，推荐<code>clashx/clash</code></li><li>详细阅读项目文档，design document等，如果是英文，最好直接自己阅读英文，而不是看别人已经翻译好的</li><li>不要使用windows，选择mac或者linux</li><li>配置好运行环境，能够debug，能够使用代码跳转，mac上推荐<code>vscode</code></li><li>从sample开始，然后是测试用例，一点一点分解</li><li>如果改项目支持插件开发，则一定要去完整的看一遍插件开发流程，并尝试开发一个插件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;怎样选择一个开源项目去学习&quot;&gt;&lt;a href=&quot;#怎样选择一个开源项目去学习&quot; class=&quot;headerlink&quot; title=&quot;怎样选择一个开源项目去学习&quot;&gt;&lt;/a&gt;怎样选择一个开源项目去学习&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;文档要丰富，包括user guide，d
      
    
    </summary>
    
    
      <category term="方法" scheme="https://micsay.com/categories/%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="姿势" scheme="https://micsay.com/tags/%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
</feed>
