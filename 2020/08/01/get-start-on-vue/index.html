<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
<script data-ad-client="ca-pub-6412444017075171" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpeg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpeg">
  <link rel="mask-icon" href="/images/avatar.jpeg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://micsay.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="特别声明：本文未经许可禁止转载  开头 不能免俗，我也要做Vue源码解析了 本文基于Vue 2.5.8-beta版本进行分析 源码讲解的第一行附了源码路径，可供查看，我会在我认为重要的地方加注释 如果有疑问，可以留言或者关注我公众号并发送消息 本文通俗易懂，不人云亦云，应该都能看得懂  Vue Compiler：编译Vue模版 先来看一下，开发者开发时的Vue代码结构12345&lt;templ">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue源码解析">
<meta property="og:url" content="https://micsay.com/2020/08/01/get-start-on-vue/index.html">
<meta property="og:site_name" content="细水会流长">
<meta property="og:description" content="特别声明：本文未经许可禁止转载  开头 不能免俗，我也要做Vue源码解析了 本文基于Vue 2.5.8-beta版本进行分析 源码讲解的第一行附了源码路径，可供查看，我会在我认为重要的地方加注释 如果有疑问，可以留言或者关注我公众号并发送消息 本文通俗易懂，不人云亦云，应该都能看得懂  Vue Compiler：编译Vue模版 先来看一下，开发者开发时的Vue代码结构12345&lt;templ">
<meta property="article:published_time" content="2020-08-01T04:48:02.000Z">
<meta property="article:modified_time" content="2020-08-08T09:37:16.711Z">
<meta property="article:author" content="崔怀祥">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://micsay.com/2020/08/01/get-start-on-vue/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Vue源码解析 | 细水会流长</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-161259091-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-161259091-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="细水会流长" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">细水会流长</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">不积跬步，无以至千里</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://micsay.com/2020/08/01/get-start-on-vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="崔怀祥">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="细水会流长">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Vue源码解析
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-01 12:48:02" itemprop="dateCreated datePublished" datetime="2020-08-01T12:48:02+08:00">2020-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-08 17:37:16" itemprop="dateModified" datetime="2020-08-08T17:37:16+08:00">2020-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>特别声明：本文未经许可禁止转载</p>
</blockquote>
<h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><ul>
<li>不能免俗，我也要做Vue源码解析了</li>
<li>本文基于<code>Vue 2.5.8-beta</code>版本进行分析</li>
<li>源码讲解的第一行附了源码路径，可供查看，我会在我认为重要的地方加注释</li>
<li>如果有疑问，可以留言或者关注我公众号并发送消息</li>
<li>本文通俗易懂，不人云亦云，应该都能看得懂</li>
</ul>
<h3 id="Vue-Compiler：编译Vue模版"><a href="#Vue-Compiler：编译Vue模版" class="headerlink" title="Vue Compiler：编译Vue模版"></a>Vue Compiler：编译Vue模版</h3><ul>
<li>先来看一下，开发者开发时的Vue代码结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;Hello World&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure></li>
<li>以上代码，经过Vue compiler处理之后，template会变成<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_c(&quot;div&quot;, [_c(&quot;span&quot;, [_vm._v(&quot;Hello World&quot;)])])</span><br></pre></td></tr></table></figure></li>
<li>其中，_c就是createElement，定义在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;render.js</span><br><span class="line">vm._c &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, false)</span><br></pre></td></tr></table></figure></li>
<li>看一下Vue compiler入口，可猜出该部分的功能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;compiler&#x2F;index.js</span><br><span class="line">export const createCompiler &#x3D; createCompilerCreator(function baseCompile (</span><br><span class="line">  template: string,</span><br><span class="line">  options: CompilerOptions</span><br><span class="line">): CompiledResult &#123;</span><br><span class="line">  const ast &#x3D; parse(template.trim(), options)</span><br><span class="line">  if (options.optimize !&#x3D;&#x3D; false) &#123;</span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  const code &#x3D; generate(ast, options)</span><br><span class="line">  return &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>输入是模版string，输出是render函数，而这个render函数，将会被Vue-loader使用，将其声明到options中，后面Vue.prototype._render()函数中使用到到options.render(xx)函数，就是由此而来。另外Vue compiler还对某些Vue特性做了处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render &#x3D; function (): VNode &#123;</span><br><span class="line">    const vm: Component &#x3D; this</span><br><span class="line">    const &#123; render, _parentVnode &#125; &#x3D; vm.$options &#x2F;&#x2F; 1. 该render函数就是Vue compiler编译输出的</span><br><span class="line"></span><br><span class="line">    if (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots &#x3D; _parentVnode.data.scopedSlots || emptyObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; set parent vnode. this allows render functions to have access</span><br><span class="line">    &#x2F;&#x2F; to the data on the placeholder node.</span><br><span class="line">    vm.$vnode &#x3D; _parentVnode</span><br><span class="line">    &#x2F;&#x2F; render self</span><br><span class="line">    let vnode</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 2、生成vnode，供后面做VDOM DIFF时使用</span><br><span class="line">      vnode &#x3D; render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">      handleError(e, vm, &#96;render&#96;)</span><br><span class="line">      &#x2F;&#x2F; return error render result,</span><br><span class="line">      &#x2F;&#x2F; or previous vnode to prevent render error causing blank component</span><br><span class="line">      &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          vnode &#x3D; vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          handleError(e, vm, &#96;renderError&#96;)</span><br><span class="line">          vnode &#x3D; vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode &#x3D; vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; return empty vnode in case the render function errored out</span><br><span class="line">    if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; Array.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Multiple root nodes returned from render function. Render function &#39; +</span><br><span class="line">          &#39;should return a single root node.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode &#x3D; createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; set parent</span><br><span class="line">    vnode.parent &#x3D; _parentVnode</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Vue-Instance第一次渲染（总计有12个重要注释）"><a href="#Vue-Instance第一次渲染（总计有12个重要注释）" class="headerlink" title="Vue Instance第一次渲染（总计有12个重要注释）"></a>Vue Instance第一次渲染（总计有12个重要注释）</h3><ul>
<li>一切要从<code>new Vue(options)</code>开始<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello Vue!&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>其实在<code>new Vue(options)</code>之前，需要先考虑<code>Vue Constructor</code>的初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</span><br><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&#39;Vue is a constructor and should be called with the &#96;new&#96; keyword&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options) &#x2F;&#x2F; 1. new Vue(options)时执行</span><br><span class="line">  &#x2F;&#x2F; _init方法即Vue.prototype._init</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2. 以下方法调用，就是在初始化Vue Constructor，从方法名不难猜出其功能</span><br><span class="line">initMixin(Vue) </span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure></li>
<li>在<code>this._init(options)</code>方法中，初始化<code>Vue Instance</code>，我们来看看<code>_init</code>方法的定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;init.js</span><br><span class="line">  Vue.prototype._init &#x3D; function (options?: Object) &#123; </span><br><span class="line">    &#x2F;&#x2F; 3. 你可能奇怪javascript怎么会有类型声明，这是prop-types在编译时用到的，</span><br><span class="line">    &#x2F;&#x2F; 编译结束之后，就是纯碎的javascript代码了</span><br><span class="line">    const vm: Component &#x3D; this</span><br><span class="line">    &#x2F;&#x2F; a uid</span><br><span class="line">    vm._uid &#x3D; uid++</span><br><span class="line"></span><br><span class="line">    let startTag, endTag</span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag &#x3D; &#96;vue-perf-start:$&#123;vm._uid&#125;&#96;</span><br><span class="line">      endTag &#x3D; &#96;vue-perf-end:$&#123;vm._uid&#125;&#96;</span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; a flag to avoid this being observed</span><br><span class="line">    vm._isVue &#x3D; true</span><br><span class="line">    &#x2F;&#x2F; merge options</span><br><span class="line">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      &#x2F;&#x2F; optimize internal component instantiation</span><br><span class="line">      &#x2F;&#x2F; since dynamic options merging is pretty slow, and none of the</span><br><span class="line">      &#x2F;&#x2F; internal component options needs special treatment.</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm.$options &#x3D; mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy &#x3D; vm</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; expose real self</span><br><span class="line">    vm._self &#x3D; vm</span><br><span class="line">    &#x2F;&#x2F; 4、下面的以init开头的方法，都是根据options，给vm即this塞必要的属性方便开发时使用</span><br><span class="line">    &#x2F;&#x2F; 以call开头的方法，都是在触发Vue的声明周期</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &#39;beforeCreate&#39;)</span><br><span class="line">    initInjections(vm) &#x2F;&#x2F; resolve injections before data&#x2F;props</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) &#x2F;&#x2F; resolve provide after data&#x2F;props</span><br><span class="line">    callHook(vm, &#39;created&#39;)</span><br><span class="line"></span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name &#x3D; formatComponentName(vm, false)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;vm._name&#125; init&#96;, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el) &#x2F;&#x2F; 5、$mount方法，就是mountComponent方法，定义在 &#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js中</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>执行<code>$mount</code>方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js</span><br><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component, &#x2F;&#x2F; 6、vm即this、即Vue Instance</span><br><span class="line">  el: ?Element, &#x2F;&#x2F; 7、new Vue(options)时传入的el</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el &#x3D; el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render &#x3D; createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !&#x3D;&#x3D; &#39;#&#39;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;You are using the runtime-only build of Vue where the template &#39; +</span><br><span class="line">          &#39;compiler is not available. Either pre-compile the templates into &#39; +</span><br><span class="line">          &#39;render functions, or use the compiler-included build.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Failed to mount component: template or render function not defined.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &#39;beforeMount&#39;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      const name &#x3D; vm._name</span><br><span class="line">      const id &#x3D; vm._uid</span><br><span class="line">      const startTag &#x3D; &#96;vue-perf-start:$&#123;id&#125;&#96;</span><br><span class="line">      const endTag &#x3D; &#96;vue-perf-end:$&#123;id&#125;&#96;</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode &#x3D; vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;name&#125; render&#96;, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;name&#125; patch&#96;, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 8、定义updateComponent方法传给Watcher，</span><br><span class="line">    &#x2F;&#x2F; 使用Watcher去watch options中定义的data，一旦data中的数据发生变动，则触发updateComponent</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">      &#x2F;&#x2F; 9、_render方法即Vue.prototype._render，定义在 &#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;render.js，</span><br><span class="line">      &#x2F;&#x2F; 该方法调用了options中的render方法生成了vnode而vnode是VDOM的基础之一，而options中的render方法，则是在Vue Compile阶段</span><br><span class="line">      &#x2F;&#x2F; 根据开发者定义的Vue Template生成的</span><br><span class="line">      &#x2F;&#x2F; 10、_update方法即Vue.prototype._update，定义在 &#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js，</span><br><span class="line">      该方法主要是执行patch方法，而patch方法第一个参数是preVnode，第二个参数是vnode。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; we set this to vm._watcher inside the watcher&#39;s constructor</span><br><span class="line">  &#x2F;&#x2F; since the watcher&#39;s initial patch may call $forceUpdate (e.g. inside child</span><br><span class="line">  &#x2F;&#x2F; component&#39;s mounted hook), which relies on vm._watcher being already defined</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 11、new Watcher(xxx)时，将会在Watcher Constructor中调用传入的updateComponent方法，</span><br><span class="line">  因此，当new Watcher(xxx)执行完毕，DOM操作已经执行完成，页面已经渲染出来了</span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;  </span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, &#39;beforeUpdate&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true &#x2F;* isRenderWatcher *&#x2F;)</span><br><span class="line">  hydrating &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; manually mounted instance, call mounted on self</span><br><span class="line">  &#x2F;&#x2F; mounted is called for render-created child components in its inserted hook</span><br><span class="line">  if (vm.$vnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">    vm._isMounted &#x3D; true</span><br><span class="line">    callHook(vm, &#39;mounted&#39;) &#x2F;&#x2F; 12、第一次渲染完成，由此可以得出结论，Vue是以组件为单位进行watch的</span><br><span class="line">    &#x2F;&#x2F; 那么，如果合理的对Vue代码进行封装，封装成组件，则有可能有效的减少VDOM DIFF时的节点数量</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Vue-VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）"><a href="#Vue-VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）" class="headerlink" title="Vue VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）"></a>Vue VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）</h3><blockquote>
<p>VDOM其实是一个定义，是为了与真实DOM相区分而起的名字，不要被吓到，说白了，其实就是用JavaScript的Object（没错就是Vnode）为节点，构成的一棵树，每个节点上有parent、children以及其他信息，这棵树尽可能的与真实的DOM树相匹配，在数据被更新时，生成新VDOM Tree，与旧的VDOM Tree相比对，通过DIFF算法，比对出，需要怎么样操作DOM，才能正确更新</p>
</blockquote>
<ul>
<li><p>既然Vnode是基础，先看一下Vnode的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;vnode.js</span><br><span class="line">export default class VNode &#123;</span><br><span class="line">  tag: string | void; &#x2F;&#x2F; 1、如vue-compoment-keep-alive</span><br><span class="line">  data: VNodeData | void; &#x2F;&#x2F; 2、patch运行时用到的数据，比如hooks，keepAlive </span><br><span class="line">  children: ?Array&lt;VNode&gt;;</span><br><span class="line">  text: string | void;</span><br><span class="line">  elm: Node | void; &#x2F;&#x2F; 3、真实的DOM节点</span><br><span class="line">  ns: string | void;</span><br><span class="line">  context: Component | void; &#x2F;&#x2F; rendered in this component&#39;s scope</span><br><span class="line">  key: string | number | void;</span><br><span class="line">  componentOptions: VNodeComponentOptions | void; &#x2F;&#x2F; 4、组件的options</span><br><span class="line">  componentInstance: Component | void; &#x2F;&#x2F; component instance &#x2F;&#x2F; 5、组件new完之后的Vue Instance</span><br><span class="line">  parent: VNode | void; &#x2F;&#x2F; component placeholder node</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; strictly internal</span><br><span class="line">  raw: boolean; &#x2F;&#x2F; contains raw HTML? (server only)</span><br><span class="line">  isStatic: boolean; &#x2F;&#x2F; hoisted static node</span><br><span class="line">  isRootInsert: boolean; &#x2F;&#x2F; necessary for enter transition check</span><br><span class="line">  isComment: boolean; &#x2F;&#x2F; empty comment placeholder?</span><br><span class="line">  isCloned: boolean; &#x2F;&#x2F; is a cloned node?</span><br><span class="line">  isOnce: boolean; &#x2F;&#x2F; is a v-once node?</span><br><span class="line">  asyncFactory: Function | void; &#x2F;&#x2F; async component factory function</span><br><span class="line">  asyncMeta: Object | void;</span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  ssrContext: Object | void;</span><br><span class="line">  fnContext: Component | void; &#x2F;&#x2F; real context vm for functional nodes</span><br><span class="line">  fnOptions: ?ComponentOptions; &#x2F;&#x2F; for SSR caching</span><br><span class="line">  devtoolsMeta: ?Object; &#x2F;&#x2F; used to store functional render context for devtools</span><br><span class="line">  fnScopeId: ?string; &#x2F;&#x2F; functional scope id support</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.tag &#x3D; tag</span><br><span class="line">    this.data &#x3D; data</span><br><span class="line">    this.children &#x3D; children</span><br><span class="line">    this.text &#x3D; text</span><br><span class="line">    this.elm &#x3D; elm</span><br><span class="line">    this.ns &#x3D; undefined</span><br><span class="line">    this.context &#x3D; context</span><br><span class="line">    this.fnContext &#x3D; undefined</span><br><span class="line">    this.fnOptions &#x3D; undefined</span><br><span class="line">    this.fnScopeId &#x3D; undefined</span><br><span class="line">    this.key &#x3D; data &amp;&amp; data.key</span><br><span class="line">    this.componentOptions &#x3D; componentOptions</span><br><span class="line">    this.componentInstance &#x3D; undefined</span><br><span class="line">    this.parent &#x3D; undefined</span><br><span class="line">    this.raw &#x3D; false</span><br><span class="line">    this.isStatic &#x3D; false</span><br><span class="line">    this.isRootInsert &#x3D; true</span><br><span class="line">    this.isComment &#x3D; false</span><br><span class="line">    this.isCloned &#x3D; false</span><br><span class="line">    this.isOnce &#x3D; false</span><br><span class="line">    this.asyncFactory &#x3D; asyncFactory</span><br><span class="line">    this.asyncMeta &#x3D; undefined</span><br><span class="line">    this.isAsyncPlaceholder &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; DEPRECATED: alias for componentInstance for backwards compat.</span><br><span class="line">  &#x2F;* istanbul ignore next *&#x2F;</span><br><span class="line">  get child (): Component | void &#123;</span><br><span class="line">    return this.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>先解释一下Patch，Patch是Vue VDOM部分中的一个函数，该函数就是<code>Vue.prototype.__patch__</code>，而该函数其实就是在做DIFF，输入是oldVnode、vnode，输出是DIFF后，需要对真实DOM节点所做对DOM操作，比如createElemennt、insertBefore、appendChild等等，而驱动该函数运行的，是Watcher，而Watcher观察的，是data。因此，开发者只需要改变Vue options中的data，就能完成想要的更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;patch.js</span><br><span class="line">function patch (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    &#x2F;&#x2F; 6、输入参数是oldVnode、vnode，就是对oldVnode和vnode做DIFF</span><br><span class="line">    if (isUndef(vnode)) &#123;</span><br><span class="line">      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let isInitialPatch &#x3D; false</span><br><span class="line">    const insertedVnodeQueue &#x3D; []</span><br><span class="line"></span><br><span class="line">    if (isUndef(oldVnode)) &#123;</span><br><span class="line">      &#x2F;&#x2F; empty mount (likely as component), create new root element</span><br><span class="line">      isInitialPatch &#x3D; true</span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const isRealElement &#x3D; isDef(oldVnode.nodeType)</span><br><span class="line">      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        &#x2F;&#x2F; patch existing root node</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 7、开始做DIFF</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (isRealElement) &#123;</span><br><span class="line">          &#x2F;&#x2F; mounting to a real element</span><br><span class="line">          &#x2F;&#x2F; check if this is server-rendered content and if we can perform</span><br><span class="line">          &#x2F;&#x2F; a successful hydration.</span><br><span class="line">          if (oldVnode.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating &#x3D; true</span><br><span class="line">          &#125;</span><br><span class="line">          if (isTrue(hydrating)) &#123;</span><br><span class="line">            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, true)</span><br><span class="line">              return oldVnode</span><br><span class="line">            &#125; else if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                &#39;The client-side rendered virtual DOM tree is not matching &#39; +</span><br><span class="line">                &#39;server-rendered content. This is likely caused by incorrect &#39; +</span><br><span class="line">                &#39;HTML markup, for example nesting block-level elements inside &#39; +</span><br><span class="line">                &#39;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#39; +</span><br><span class="line">                &#39;full client-side render.&#39;</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; either not server-rendered, or hydration failed.</span><br><span class="line">          &#x2F;&#x2F; create an empty node and replace it</span><br><span class="line">          oldVnode &#x3D; emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; replacing existing element</span><br><span class="line">        const oldElm &#x3D; oldVnode.elm</span><br><span class="line">        const parentElm &#x3D; nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; create new node</span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          &#x2F;&#x2F; extremely rare edge case: do not insert if old element is in a</span><br><span class="line">          &#x2F;&#x2F; leaving transition. Only happens when combining transition +</span><br><span class="line">          &#x2F;&#x2F; keep-alive + HOCs. (#4590)</span><br><span class="line">          oldElm._leaveCb ? null : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; update parent placeholder node element, recursively</span><br><span class="line">        if (isDef(vnode.parent)) &#123;</span><br><span class="line">          let ancestor &#x3D; vnode.parent</span><br><span class="line">          const patchable &#x3D; isPatchable(vnode)</span><br><span class="line">          while (ancestor) &#123;</span><br><span class="line">            for (let i &#x3D; 0; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm &#x3D; vnode.elm</span><br><span class="line">            if (patchable) &#123;</span><br><span class="line">              for (let i &#x3D; 0; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              &#x2F;&#x2F; #6513</span><br><span class="line">              &#x2F;&#x2F; invoke insert hooks that may have been merged by create hooks.</span><br><span class="line">              &#x2F;&#x2F; e.g. for directives that uses the &quot;inserted&quot; hook.</span><br><span class="line">              const insert &#x3D; ancestor.data.hook.insert</span><br><span class="line">              if (insert.merged) &#123;</span><br><span class="line">                &#x2F;&#x2F; start at index 1 to avoid re-invoking component mounted hook</span><br><span class="line">                for (let i &#x3D; 1; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor &#x3D; ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; destroy old node</span><br><span class="line">        if (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes(parentElm, [oldVnode], 0, 0)</span><br><span class="line">        &#125; else if (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    return vnode.elm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们来看一下patchVnode函数。整个VDOM树，每个节点都有parent和children，而patchVnode其实在做的是：比对oldVnode’s children与vnode’s children</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">function patchVnode (</span><br><span class="line">    oldVnode,</span><br><span class="line">    vnode,</span><br><span class="line">    insertedVnodeQueue,</span><br><span class="line">    ownerArray,</span><br><span class="line">    index,</span><br><span class="line">    removeOnly</span><br><span class="line">  ) &#123;</span><br><span class="line">    if (oldVnode &#x3D;&#x3D;&#x3D; vnode) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">      &#x2F;&#x2F; clone reused vnode</span><br><span class="line">      vnode &#x3D; ownerArray[index] &#x3D; cloneVNode(vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const elm &#x3D; vnode.elm &#x3D; oldVnode.elm</span><br><span class="line"></span><br><span class="line">    if (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">      if (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode.isAsyncPlaceholder &#x3D; true</span><br><span class="line">      &#125;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; reuse element for static trees.</span><br><span class="line">    &#x2F;&#x2F; note we only do this if the vnode is cloned -</span><br><span class="line">    &#x2F;&#x2F; if the new node is not cloned it means the render functions have been</span><br><span class="line">    &#x2F;&#x2F; reset by the hot-reload-api and we need to do a proper re-render.</span><br><span class="line">    if (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">      isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">      vnode.key &#x3D;&#x3D;&#x3D; oldVnode.key &amp;&amp;</span><br><span class="line">      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.componentInstance &#x3D; oldVnode.componentInstance</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let i</span><br><span class="line">    const data &#x3D; vnode.data</span><br><span class="line">    if (isDef(data) &amp;&amp; isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const oldCh &#x3D; oldVnode.children</span><br><span class="line">    const ch &#x3D; vnode.children</span><br><span class="line">    if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      for (i &#x3D; 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isUndef(vnode.text)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 8、如果children都存在，则比对children</span><br><span class="line">      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; else if (isDef(ch)) &#123; &#x2F;&#x2F; 9、如果只有vnode上存在children，则这些children都需被add</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          checkDuplicateKeys(ch)</span><br><span class="line">        &#125;</span><br><span class="line">        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)</span><br><span class="line">        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">      &#125; else if (isDef(oldCh)) &#123; &#x2F;&#x2F; 10、如果只有oldVnode上存在children，则这些children都需被删除</span><br><span class="line">        removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">      &#125; else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, &#39;&#39;) &#x2F;&#x2F; 11、针对text 节点做单独处理</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123; &#x2F;&#x2F; 12、针对text节点做单独处理</span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isDef(data)) &#123;</span><br><span class="line">      if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在看updateChildren之前，先看一个函数sameVnode，该函数的用途是，判断节点a和节点b的真实DOM节点是否一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function sameVnode (a, b) &#123;</span><br><span class="line">  return (</span><br><span class="line">    a.key &#x3D;&#x3D;&#x3D; b.key &amp;&amp; ( &#x2F;&#x2F; 13、这里会先判断key，因此设置一个合适的key的重要性不言而喻。</span><br><span class="line">    &#x2F;&#x2F; 当前后两次Patch更新时，如果key不变，那么就不会产生不必要的DOM操作</span><br><span class="line">      (</span><br><span class="line">        a.tag &#x3D;&#x3D;&#x3D; b.tag &amp;&amp;</span><br><span class="line">        a.isComment &#x3D;&#x3D;&#x3D; b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) &#x3D;&#x3D;&#x3D; isDef(b.data) &amp;&amp;</span><br><span class="line">        !childrenIgnored(a) &amp;&amp; !childrenIgnored(b) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory &#x3D;&#x3D;&#x3D; b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再看一下updateChildren函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;patch.js</span><br><span class="line">  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    let oldStartIdx &#x3D; 0</span><br><span class="line">    let newStartIdx &#x3D; 0</span><br><span class="line">    let oldEndIdx &#x3D; oldCh.length - 1</span><br><span class="line">    let oldStartVnode &#x3D; oldCh[0]</span><br><span class="line">    let oldEndVnode &#x3D; oldCh[oldEndIdx]</span><br><span class="line">    let newEndIdx &#x3D; newCh.length - 1</span><br><span class="line">    let newStartVnode &#x3D; newCh[0]</span><br><span class="line">    let newEndVnode &#x3D; newCh[newEndIdx]</span><br><span class="line">    let oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">    &#x2F;&#x2F; to ensure removed elements stay in correct relative positions</span><br><span class="line">    &#x2F;&#x2F; during leaving transitions</span><br><span class="line">    const canMove &#x3D; !removeOnly</span><br><span class="line"></span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 14、假设old children是[A, B, C, D]</span><br><span class="line">    &#x2F;&#x2F; new children是[B, C, D]</span><br><span class="line">    &#x2F;&#x2F; 那么，根据下面的循环，DIFF后的DOM操作是 removeChild(A)</span><br><span class="line">    &#x2F;&#x2F; 其实，该函数的最终目的是：在尽量减少DOM操作的前提下，找出old children中能继续使用的真实DOM节点，</span><br><span class="line">    &#x2F;&#x2F; 并保证new children中的节点能够正确的更新</span><br><span class="line">    while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) &#123;</span><br><span class="line">      if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode &#x3D; oldCh[++oldStartIdx] &#x2F;&#x2F; Vnode has been moved left</span><br><span class="line">      &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode &#x3D; oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode &#x3D; newCh[--newEndIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; &#x2F;&#x2F; Vnode moved right</span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        &#x2F;&#x2F; 15、产生DOM操作insertBefore</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode &#x3D; oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode &#x3D; newCh[--newEndIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; &#x2F;&#x2F; Vnode moved left</span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (isUndef(oldKeyToIdx)) oldKeyToIdx &#x3D; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        &#x2F;&#x2F; 16、如果定义了key，则时间复杂度为O(1)，如果没有定义key，则时间复杂度为O(n)</span><br><span class="line">        idxInOld &#x3D; isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        if (isUndef(idxInOld)) &#123; &#x2F;&#x2F; New element</span><br><span class="line">          &#x2F;&#x2F; 17、产生DOM操作appendChild or insertBefore</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          vnodeToMove &#x3D; oldCh[idxInOld]</span><br><span class="line">          if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] &#x3D; undefined</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; same key but different element. treat as new element</span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm &#x3D; isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">      &#x2F;&#x2F; 18、产生DOM操作</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      &#x2F;&#x2F; 19、产生DOM操作</span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结一下整个过程</p>
<ul>
<li>在Vue.prototype._init()中，Watcher将会watch options data等关键位置</li>
<li>开发者代码中更新了options data</li>
<li>Watcher watch到改变，触发updateComponent</li>
<li>调用options中的render函数，生成新vnode</li>
<li>紧接着调用patch，与oldVnode做对比，输出是：需要对真实DOM所做的操作</li>
<li>更新完成</li>
</ul>
</li>
</ul>
<h3 id="Vue-Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）"><a href="#Vue-Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）" class="headerlink" title="Vue Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）"></a>Vue Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）</h3><ul>
<li><p>上面多次提到了Watcher，Watcher在Vue中的作用有很多，比如</p>
<ul>
<li>上面提到的options data，更新options data触发视图更新</li>
<li>computed特性，更新options data后，更新computed的属性绑定的视图</li>
<li>Vue中手动watch特性</li>
<li>Vuex的实现，也是借助于Watcher</li>
</ul>
</li>
<li><p>整个Watcher其实就是观察者模式，只不过，register是全自动的，不需要开发者关心，我们将重点关注是如何实现全自动register</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;observer&#x2F;watcher.js</span><br><span class="line">export default class Watcher &#123;</span><br><span class="line">  vm: Component; &#x2F;&#x2F; 1、Vue实例</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: Function;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: Array&lt;Dep&gt;;</span><br><span class="line">  newDeps: Array&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?Function;</span><br><span class="line">  getter: Function; &#x2F;&#x2F; 2、当监听到变动是，需要执行到函数</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean &#x2F;&#x2F; 3、mountComponent函数执行时，会new Watcher(xxx)</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.vm &#x3D; vm</span><br><span class="line">    if (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher &#x3D; this</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(this)</span><br><span class="line">    &#x2F;&#x2F; options</span><br><span class="line">    if (options) &#123;</span><br><span class="line">      this.deep &#x3D; !!options.deep</span><br><span class="line">      this.user &#x3D; !!options.user</span><br><span class="line">      this.lazy &#x3D; !!options.lazy</span><br><span class="line">      this.sync &#x3D; !!options.sync</span><br><span class="line">      this.before &#x3D; options.before</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.deep &#x3D; this.user &#x3D; this.lazy &#x3D; this.sync &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    this.cb &#x3D; cb</span><br><span class="line">    this.id &#x3D; ++uid &#x2F;&#x2F; uid for batching</span><br><span class="line">    this.active &#x3D; true</span><br><span class="line">    this.dirty &#x3D; this.lazy &#x2F;&#x2F; for lazy watchers</span><br><span class="line">    this.deps &#x3D; []</span><br><span class="line">    this.newDeps &#x3D; []</span><br><span class="line">    this.depIds &#x3D; new Set()</span><br><span class="line">    this.newDepIds &#x3D; new Set()</span><br><span class="line">    this.expression &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : &#39;&#39;</span><br><span class="line">    &#x2F;&#x2F; parse expression for getter</span><br><span class="line">    if (typeof expOrFn &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      this.getter &#x3D; expOrFn &#x2F;&#x2F; 4、expOrFn即mountComponent函数中到updateComponent函数</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getter &#x3D; parsePath(expOrFn)</span><br><span class="line">      if (!this.getter) &#123;</span><br><span class="line">        this.getter &#x3D; noop</span><br><span class="line">        process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">          &#96;Failed watching path: &quot;$&#123;expOrFn&#125;&quot; &#96; +</span><br><span class="line">          &#39;Watcher only accepts simple dot-delimited paths. &#39; +</span><br><span class="line">          &#39;For full control, use a function instead.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value &#x3D; this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get() &#x2F;&#x2F; 5、在Watcher构造函数中执行get()函数</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Evaluate the getter, and re-collect dependencies.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(this) &#x2F;&#x2F; 6、此处是关键，将会使得 Dep.target &#x3D;&#x3D;&#x3D; this</span><br><span class="line">    let value</span><br><span class="line">    const vm &#x3D; this.vm</span><br><span class="line">    try &#123;</span><br><span class="line">      value &#x3D; this.getter.call(vm, vm) </span><br><span class="line">      &#x2F;&#x2F; 6、第一次执行updateComponent函数，</span><br><span class="line">      &#x2F;&#x2F; updateComponent会依次调用Vue.prototype._render()生成VDOM树、</span><br><span class="line">      &#x2F;&#x2F; Vue.prototype._update()进行patch、patch()、产生DOM操作</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (this.user) &#123;</span><br><span class="line">        handleError(e, vm, &#96;getter for watcher &quot;$&#123;this.expression&#125;&quot;&#96;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">      &#x2F;&#x2F; dependencies for deep watching</span><br><span class="line">      if (this.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      this.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Add a dependency to this directive.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    const id &#x3D; dep.id</span><br><span class="line">    if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">      this.newDepIds.add(id)</span><br><span class="line">      this.newDeps.push(dep)</span><br><span class="line">      if (!this.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(this) &#x2F;&#x2F; 7、向Dep实例中添加 this ，</span><br><span class="line">        &#x2F;&#x2F; 当被defineReactive后的字段（比如data中当字段）被更新，</span><br><span class="line">        &#x2F;&#x2F; Dep类的notify()函数会被调用，紧接着会调用 this.update()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Clean up for dependency collection.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    let i &#x3D; this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      const dep &#x3D; this.deps[i]</span><br><span class="line">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tmp &#x3D; this.depIds</span><br><span class="line">    this.depIds &#x3D; this.newDepIds</span><br><span class="line">    this.newDepIds &#x3D; tmp</span><br><span class="line">    this.newDepIds.clear()</span><br><span class="line">    tmp &#x3D; this.deps</span><br><span class="line">    this.deps &#x3D; this.newDeps</span><br><span class="line">    this.newDeps &#x3D; tmp</span><br><span class="line">    this.newDeps.length &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Subscriber interface.</span><br><span class="line">   * Will be called when a dependency changes.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  update () &#123;</span><br><span class="line">    &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty &#x3D; true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      queueWatcher(this) &#x2F;&#x2F; 8、将Watcher加入队列，</span><br><span class="line">      &#x2F;&#x2F; 这是Vue异步渲染的原理，</span><br><span class="line">      &#x2F;&#x2F; 队列中的Watcher将会在下一个tick中被调用this.run() 函数，</span><br><span class="line">      &#x2F;&#x2F; this.run() 最终会调用 this.getter() 函数，</span><br><span class="line">      &#x2F;&#x2F; 如果 this 是Vue组件实例对应的Watcher，</span><br><span class="line">      &#x2F;&#x2F; 那么，就会触发updateComponent被调用</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Scheduler job interface.</span><br><span class="line">   * Will be called by the scheduler.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  run () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      const value &#x3D; this.get()</span><br><span class="line">      if (</span><br><span class="line">        value !&#x3D;&#x3D; this.value ||</span><br><span class="line">        &#x2F;&#x2F; Deep watchers and watchers on Object&#x2F;Arrays should fire even</span><br><span class="line">        &#x2F;&#x2F; when the value is the same, because the value may</span><br><span class="line">        &#x2F;&#x2F; have mutated.</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        this.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; set new value</span><br><span class="line">        const oldValue &#x3D; this.value</span><br><span class="line">        this.value &#x3D; value</span><br><span class="line">        if (this.user) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            this.cb.call(this.vm, value, oldValue)</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            handleError(e, this.vm, &#96;callback for watcher &quot;$&#123;this.expression&#125;&quot;&#96;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.cb.call(this.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Evaluate the value of the watcher.</span><br><span class="line">   * This only gets called for lazy watchers.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    this.value &#x3D; this.get()</span><br><span class="line">    this.dirty &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Depend on all deps collected by this watcher.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  depend () &#123;</span><br><span class="line">    let i &#x3D; this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      this.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Remove self from all dependencies&#39; subscriber list.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  teardown () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      &#x2F;&#x2F; remove self from vm&#39;s watcher list</span><br><span class="line">      &#x2F;&#x2F; this is a somewhat expensive operation so we skip it</span><br><span class="line">      &#x2F;&#x2F; if the vm is being destroyed.</span><br><span class="line">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(this.vm._watchers, this)</span><br><span class="line">      &#125;</span><br><span class="line">      let i &#x3D; this.deps.length</span><br><span class="line">      while (i--) &#123;</span><br><span class="line">        this.deps[i].removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">      this.active &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>另一个很重要的类是：Dep</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;observer&#x2F;dep.js</span><br><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher; &#x2F;&#x2F; 9、这是关键变量：Vue用该全局变量，</span><br><span class="line">  &#x2F;&#x2F; 来保存当前正在watch的Watcher实例是哪个，这是依赖收集的关键</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;; &#x2F;&#x2F; 10、该属性表示所有正在watch该Dep实例的Watcher。</span><br><span class="line">  &#x2F;&#x2F; 一个Dep实例对应了一个data中的一个字段，</span><br><span class="line">  &#x2F;&#x2F; 当该字段被更新，将会触发Watcher运行this.run()</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id &#x3D; uid++</span><br><span class="line">    this.subs &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(this) &#x2F;&#x2F; 11、该方法会调用Dep类的addSub方法，</span><br><span class="line">      &#x2F;&#x2F; 最终的结果是，将Dep.target保存的Watcher实例加入到Dep的subs数组中，</span><br><span class="line">      &#x2F;&#x2F; 后续更新字段触发Dep类的notify时，运行该Watcher实例</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123; &#x2F;&#x2F; 12、当被defineReactive后的字段更新后，notify会被执行</span><br><span class="line">    &#x2F;&#x2F; stabilize the subscriber list first</span><br><span class="line">    const subs &#x3D; this.subs.slice()</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; !config.async) &#123;</span><br><span class="line">      &#x2F;&#x2F; subs aren&#39;t sorted in scheduler if not running async</span><br><span class="line">      &#x2F;&#x2F; we need to sort them now to make sure they fire in correct</span><br><span class="line">      &#x2F;&#x2F; order</span><br><span class="line">      subs.sort((a, b) &#x3D;&gt; a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update() &#x2F;&#x2F;13、执行Watcher实例中的update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; the current target watcher being evaluated.</span><br><span class="line">&#x2F;&#x2F; this is globally unique because there could be only one</span><br><span class="line">&#x2F;&#x2F; watcher being evaluated at any time.</span><br><span class="line">Dep.target &#x3D; null &#x2F;&#x2F; 14、该机制奏效的依据是：同一时刻，</span><br><span class="line">&#x2F;&#x2F; 只会有一个Watcher在运行，而绝大多数情况下Watcher对应的就是Vue组件实例。</span><br><span class="line">&#x2F;&#x2F; Vue的Patch更新机制，是以Vue组件为单位的</span><br><span class="line">const targetStack &#x3D; []</span><br><span class="line"></span><br><span class="line">export function pushTarget (target: ?Watcher) &#123; </span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target &#x3D; target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function popTarget () &#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target &#x3D; targetStack[targetStack.length - 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接下来就是关键方法：defineReactive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">export function defineReactive (</span><br><span class="line">  obj: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  val: any,</span><br><span class="line">  customSetter?: ?Function,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const dep &#x3D; new Dep() &#x2F;&#x2F; 15、一个字段key，对应着一个Dep实例</span><br><span class="line"></span><br><span class="line">  const property &#x3D; Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  if (property &amp;&amp; property.configurable &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; cater for pre-defined getter&#x2F;setters</span><br><span class="line">  const getter &#x3D; property &amp;&amp; property.get</span><br><span class="line">  const setter &#x3D; property &amp;&amp; property.set</span><br><span class="line">  if ((!getter || setter) &amp;&amp; arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    val &#x3D; obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let childOb &#x3D; !shallow &amp;&amp; observe(val)</span><br><span class="line">  &#x2F;&#x2F; 16、Vue的关键点，使用了Object.defineProperty，</span><br><span class="line">  &#x2F;&#x2F; 借助get&#x2F;set机制，在get时，自动收集依赖，在set时自动触发更新</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">      const value &#x3D; getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123; &#x2F;&#x2F; 17、如果当前有Watcher正在执行，</span><br><span class="line">      &#x2F;&#x2F; 说明该字段key需要进行依赖收集，那么，收集依赖</span><br><span class="line">        dep.depend() </span><br><span class="line">        if (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          if (Array.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">      const value &#x3D; getter ? getter.call(obj) : val</span><br><span class="line">      &#x2F;* eslint-disable no-self-compare *&#x2F;</span><br><span class="line">      if (newVal &#x3D;&#x3D;&#x3D; value || (newVal !&#x3D;&#x3D; newVal &amp;&amp; value !&#x3D;&#x3D; value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;* eslint-enable no-self-compare *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; #7981: for accessor properties without setter</span><br><span class="line">      if (getter &amp;&amp; !setter) return</span><br><span class="line">      if (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val &#x3D; newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb &#x3D; !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify() &#x2F;&#x2F; 18、如果该字段key被更新，运行Watcher</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="从产品角度进行总结"><a href="#从产品角度进行总结" class="headerlink" title="从产品角度进行总结"></a>从产品角度进行总结</h3><p>Vue的成功，有两个亮点可以学习：</p>
<ul>
<li>优化开发者开发体验，拉拢开发者，具体的表现有<ul>
<li>用户只需要写类似html的Vue template模版，入手容易</li>
<li>全自动watch，同时又不降低性能</li>
</ul>
</li>
<li>技术创新<ul>
<li>使用DIFF算法进行Patch更新</li>
<li>全自动Watch的设计</li>
<li>跨平台支持，横向扩大开发者队伍</li>
</ul>
</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>关注公众号：micsaycom</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="崔怀祥 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>崔怀祥
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://micsay.com/2020/08/01/get-start-on-vue/" title="Vue源码解析">https://micsay.com/2020/08/01/get-start-on-vue/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nc/4.0/zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-NC</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/08/get-start-on-vscode/" rel="prev" title="VS Code源码解析">
      <i class="fa fa-chevron-left"></i> VS Code源码解析
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#开头"><span class="nav-number">1.</span> <span class="nav-text">开头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-Compiler：编译Vue模版"><span class="nav-number">2.</span> <span class="nav-text">Vue Compiler：编译Vue模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-Instance第一次渲染（总计有12个重要注释）"><span class="nav-number">3.</span> <span class="nav-text">Vue Instance第一次渲染（总计有12个重要注释）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）"><span class="nav-number">4.</span> <span class="nav-text">Vue VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）"><span class="nav-number">5.</span> <span class="nav-text">Vue Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从产品角度进行总结"><span class="nav-number">6.</span> <span class="nav-text">从产品角度进行总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="崔怀祥"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">崔怀祥</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/effectivecui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;effectivecui" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5258674355" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5258674355" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/effectivecui" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;effectivecui" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-wechat"></i>
      欢迎关注公众号
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <div style="display: inline-block;">
            <img src="/images/qrcode.jpg" alt="">
            <p></p>
          </div>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">崔怀祥</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'bff037672f4162371de2',
      clientSecret: '5ad85e700692a124c389478a951abbe6f80ac866',
      repo: 'effectivecui.github.io',
      owner: 'effectivecui',
      admin: ['effectivecui'],
      id: '78d8bdb32d160256eaad34c0ad7e5bb2',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
