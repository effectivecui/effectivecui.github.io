<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue源码解析</title>
    <url>/2020/08/01/get-start-on-vue/</url>
    <content><![CDATA[<blockquote>
<p>特别声明：本文未经许可禁止转载</p>
</blockquote>
<h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><ul>
<li>不能免俗，我也要做Vue源码解析了</li>
<li>本文基于<code>Vue 2.5.18-beta.0</code>版本进行分析</li>
<li>源码讲解的第一行附了源码路径，可供查看，我会在我认为重要的地方加注释</li>
<li>如果有疑问，可以留言或者关注我公众号并发送消息</li>
<li>本文通俗易懂，不人云亦云，应该都能看得懂</li>
</ul>
<h3 id="Vue-Compiler：编译Vue模版"><a href="#Vue-Compiler：编译Vue模版" class="headerlink" title="Vue Compiler：编译Vue模版"></a>Vue Compiler：编译Vue模版</h3><ul>
<li>先来看一下，开发者开发时的Vue代码结构<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;Hello World&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure></li>
<li>以上代码，经过Vue compiler处理之后，template会变成<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_c(&quot;div&quot;, [_c(&quot;span&quot;, [_vm._v(&quot;Hello World&quot;)])])</span><br></pre></td></tr></table></figure></li>
<li>其中，_c就是createElement，定义在<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;render.js</span><br><span class="line">vm._c &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, false)</span><br></pre></td></tr></table></figure></li>
<li>看一下Vue compiler入口，可猜出该部分的功能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;compiler&#x2F;index.js</span><br><span class="line">export const createCompiler &#x3D; createCompilerCreator(function baseCompile (</span><br><span class="line">  template: string,</span><br><span class="line">  options: CompilerOptions</span><br><span class="line">): CompiledResult &#123;</span><br><span class="line">  const ast &#x3D; parse(template.trim(), options)</span><br><span class="line">  if (options.optimize !&#x3D;&#x3D; false) &#123;</span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  const code &#x3D; generate(ast, options)</span><br><span class="line">  return &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>输入是模版string，输出是render函数，而这个render函数，将会被Vue-loader使用，将其声明到options中，后面Vue.prototype._render()函数中使用到到options.render(xx)函数，就是由此而来。另外Vue compiler还对某些Vue特性做了处理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype._render &#x3D; function (): VNode &#123;</span><br><span class="line">    const vm: Component &#x3D; this</span><br><span class="line">    const &#123; render, _parentVnode &#125; &#x3D; vm.$options &#x2F;&#x2F; 1. 该render函数就是Vue compiler编译输出的</span><br><span class="line"></span><br><span class="line">    if (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots &#x3D; _parentVnode.data.scopedSlots || emptyObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; set parent vnode. this allows render functions to have access</span><br><span class="line">    &#x2F;&#x2F; to the data on the placeholder node.</span><br><span class="line">    vm.$vnode &#x3D; _parentVnode</span><br><span class="line">    &#x2F;&#x2F; render self</span><br><span class="line">    let vnode</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 2、生成vnode，供后面做VDOM DIFF时使用</span><br><span class="line">      vnode &#x3D; render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">      handleError(e, vm, &#96;render&#96;)</span><br><span class="line">      &#x2F;&#x2F; return error render result,</span><br><span class="line">      &#x2F;&#x2F; or previous vnode to prevent render error causing blank component</span><br><span class="line">      &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          vnode &#x3D; vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          handleError(e, vm, &#96;renderError&#96;)</span><br><span class="line">          vnode &#x3D; vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode &#x3D; vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; return empty vnode in case the render function errored out</span><br><span class="line">    if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; Array.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Multiple root nodes returned from render function. Render function &#39; +</span><br><span class="line">          &#39;should return a single root node.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode &#x3D; createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; set parent</span><br><span class="line">    vnode.parent &#x3D; _parentVnode</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Vue-Instance第一次渲染（总计有12个重要注释）"><a href="#Vue-Instance第一次渲染（总计有12个重要注释）" class="headerlink" title="Vue Instance第一次渲染（总计有12个重要注释）"></a>Vue Instance第一次渲染（总计有12个重要注释）</h3><ul>
<li>一切要从<code>new Vue(options)</code>开始<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello Vue!&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>其实在<code>new Vue(options)</code>之前，需要先考虑<code>Vue Constructor</code>的初始化<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</span><br><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&#39;Vue is a constructor and should be called with the &#96;new&#96; keyword&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options) &#x2F;&#x2F; 1. new Vue(options)时执行</span><br><span class="line">  &#x2F;&#x2F; _init方法即Vue.prototype._init</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2. 以下方法调用，就是在初始化Vue Constructor，从方法名不难猜出其功能</span><br><span class="line">initMixin(Vue) </span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure></li>
<li>在<code>this._init(options)</code>方法中，初始化<code>Vue Instance</code>，我们来看看<code>_init</code>方法的定义<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;init.js</span><br><span class="line">  Vue.prototype._init &#x3D; function (options?: Object) &#123; </span><br><span class="line">    &#x2F;&#x2F; 3. 你可能奇怪javascript怎么会有类型声明，这是prop-types在编译时用到的，</span><br><span class="line">    &#x2F;&#x2F; 编译结束之后，就是纯碎的javascript代码了</span><br><span class="line">    const vm: Component &#x3D; this</span><br><span class="line">    &#x2F;&#x2F; a uid</span><br><span class="line">    vm._uid &#x3D; uid++</span><br><span class="line"></span><br><span class="line">    let startTag, endTag</span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag &#x3D; &#96;vue-perf-start:$&#123;vm._uid&#125;&#96;</span><br><span class="line">      endTag &#x3D; &#96;vue-perf-end:$&#123;vm._uid&#125;&#96;</span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; a flag to avoid this being observed</span><br><span class="line">    vm._isVue &#x3D; true</span><br><span class="line">    &#x2F;&#x2F; merge options</span><br><span class="line">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      &#x2F;&#x2F; optimize internal component instantiation</span><br><span class="line">      &#x2F;&#x2F; since dynamic options merging is pretty slow, and none of the</span><br><span class="line">      &#x2F;&#x2F; internal component options needs special treatment.</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm.$options &#x3D; mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy &#x3D; vm</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; expose real self</span><br><span class="line">    vm._self &#x3D; vm</span><br><span class="line">    &#x2F;&#x2F; 4、下面的以init开头的方法，都是根据options，给vm即this塞必要的属性方便开发时使用</span><br><span class="line">    &#x2F;&#x2F; 以call开头的方法，都是在触发Vue的声明周期</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &#39;beforeCreate&#39;)</span><br><span class="line">    initInjections(vm) &#x2F;&#x2F; resolve injections before data&#x2F;props</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) &#x2F;&#x2F; resolve provide after data&#x2F;props</span><br><span class="line">    callHook(vm, &#39;created&#39;)</span><br><span class="line"></span><br><span class="line">    &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name &#x3D; formatComponentName(vm, false)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;vm._name&#125; init&#96;, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el) &#x2F;&#x2F; 5、$mount方法，就是mountComponent方法，定义在 &#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js中</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>执行<code>$mount</code>方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js</span><br><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component, &#x2F;&#x2F; 6、vm即this、即Vue Instance</span><br><span class="line">  el: ?Element, &#x2F;&#x2F; 7、new Vue(options)时传入的el</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el &#x3D; el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render &#x3D; createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !&#x3D;&#x3D; &#39;#&#39;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;You are using the runtime-only build of Vue where the template &#39; +</span><br><span class="line">          &#39;compiler is not available. Either pre-compile the templates into &#39; +</span><br><span class="line">          &#39;render functions, or use the compiler-included build.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#39;Failed to mount component: template or render function not defined.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &#39;beforeMount&#39;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      const name &#x3D; vm._name</span><br><span class="line">      const id &#x3D; vm._uid</span><br><span class="line">      const startTag &#x3D; &#96;vue-perf-start:$&#123;id&#125;&#96;</span><br><span class="line">      const endTag &#x3D; &#96;vue-perf-end:$&#123;id&#125;&#96;</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode &#x3D; vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;name&#125; render&#96;, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(&#96;vue $&#123;name&#125; patch&#96;, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 8、定义updateComponent方法传给Watcher，</span><br><span class="line">    &#x2F;&#x2F; 使用Watcher去watch options中定义的data，一旦data中的数据发生变动，则触发updateComponent</span><br><span class="line">    updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">      &#x2F;&#x2F; 9、_render方法即Vue.prototype._render，定义在 &#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;render.js，</span><br><span class="line">      &#x2F;&#x2F; 该方法调用了options中的render方法生成了vnode而vnode是VDOM的基础之一，而options中的render方法，则是在Vue Compile阶段</span><br><span class="line">      &#x2F;&#x2F; 根据开发者定义的Vue Template生成的</span><br><span class="line">      &#x2F;&#x2F; 10、_update方法即Vue.prototype._update，定义在 &#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js，</span><br><span class="line">      该方法主要是执行patch方法，而patch方法第一个参数是preVnode，第二个参数是vnode。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; we set this to vm._watcher inside the watcher&#39;s constructor</span><br><span class="line">  &#x2F;&#x2F; since the watcher&#39;s initial patch may call $forceUpdate (e.g. inside child</span><br><span class="line">  &#x2F;&#x2F; component&#39;s mounted hook), which relies on vm._watcher being already defined</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 11、new Watcher(xxx)时，将会在Watcher Constructor中调用传入的updateComponent方法，</span><br><span class="line">  因此，当new Watcher(xxx)执行完毕，DOM操作已经执行完成，页面已经渲染出来了</span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;  </span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, &#39;beforeUpdate&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true &#x2F;* isRenderWatcher *&#x2F;)</span><br><span class="line">  hydrating &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; manually mounted instance, call mounted on self</span><br><span class="line">  &#x2F;&#x2F; mounted is called for render-created child components in its inserted hook</span><br><span class="line">  if (vm.$vnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">    vm._isMounted &#x3D; true</span><br><span class="line">    callHook(vm, &#39;mounted&#39;) &#x2F;&#x2F; 12、第一次渲染完成，由此可以得出结论，Vue是以组件为单位进行watch的</span><br><span class="line">    &#x2F;&#x2F; 那么，如果合理的对Vue代码进行封装，封装成组件，则有可能有效的减少VDOM DIFF时的节点数量</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Vue-VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）"><a href="#Vue-VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）" class="headerlink" title="Vue VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）"></a>Vue VDOM：通过比对VDOM，计算出所需要的真实DOM操作（总计19处注释）</h3><blockquote>
<p>VDOM其实是一个定义，是为了与真实DOM相区分而起的名字，不要被吓到，说白了，其实就是用JavaScript的Object（没错就是Vnode）为节点，构成的一棵树，每个节点上有parent、children以及其他信息，这棵树尽可能的与真实的DOM树相匹配，在数据被更新时，生成新VDOM Tree，与旧的VDOM Tree相比对，通过DIFF算法，比对出，需要怎么样操作DOM，才能正确更新</p>
</blockquote>
<ul>
<li><p>既然Vnode是基础，先看一下Vnode的数据结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;vnode.js</span><br><span class="line">export default class VNode &#123;</span><br><span class="line">  tag: string | void; &#x2F;&#x2F; 1、如vue-compoment-keep-alive</span><br><span class="line">  data: VNodeData | void; &#x2F;&#x2F; 2、patch运行时用到的数据，比如hooks，keepAlive </span><br><span class="line">  children: ?Array&lt;VNode&gt;;</span><br><span class="line">  text: string | void;</span><br><span class="line">  elm: Node | void; &#x2F;&#x2F; 3、真实的DOM节点</span><br><span class="line">  ns: string | void;</span><br><span class="line">  context: Component | void; &#x2F;&#x2F; rendered in this component&#39;s scope</span><br><span class="line">  key: string | number | void;</span><br><span class="line">  componentOptions: VNodeComponentOptions | void; &#x2F;&#x2F; 4、组件的options</span><br><span class="line">  componentInstance: Component | void; &#x2F;&#x2F; component instance &#x2F;&#x2F; 5、组件new完之后的Vue Instance</span><br><span class="line">  parent: VNode | void; &#x2F;&#x2F; component placeholder node</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; strictly internal</span><br><span class="line">  raw: boolean; &#x2F;&#x2F; contains raw HTML? (server only)</span><br><span class="line">  isStatic: boolean; &#x2F;&#x2F; hoisted static node</span><br><span class="line">  isRootInsert: boolean; &#x2F;&#x2F; necessary for enter transition check</span><br><span class="line">  isComment: boolean; &#x2F;&#x2F; empty comment placeholder?</span><br><span class="line">  isCloned: boolean; &#x2F;&#x2F; is a cloned node?</span><br><span class="line">  isOnce: boolean; &#x2F;&#x2F; is a v-once node?</span><br><span class="line">  asyncFactory: Function | void; &#x2F;&#x2F; async component factory function</span><br><span class="line">  asyncMeta: Object | void;</span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  ssrContext: Object | void;</span><br><span class="line">  fnContext: Component | void; &#x2F;&#x2F; real context vm for functional nodes</span><br><span class="line">  fnOptions: ?ComponentOptions; &#x2F;&#x2F; for SSR caching</span><br><span class="line">  devtoolsMeta: ?Object; &#x2F;&#x2F; used to store functional render context for devtools</span><br><span class="line">  fnScopeId: ?string; &#x2F;&#x2F; functional scope id support</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.tag &#x3D; tag</span><br><span class="line">    this.data &#x3D; data</span><br><span class="line">    this.children &#x3D; children</span><br><span class="line">    this.text &#x3D; text</span><br><span class="line">    this.elm &#x3D; elm</span><br><span class="line">    this.ns &#x3D; undefined</span><br><span class="line">    this.context &#x3D; context</span><br><span class="line">    this.fnContext &#x3D; undefined</span><br><span class="line">    this.fnOptions &#x3D; undefined</span><br><span class="line">    this.fnScopeId &#x3D; undefined</span><br><span class="line">    this.key &#x3D; data &amp;&amp; data.key</span><br><span class="line">    this.componentOptions &#x3D; componentOptions</span><br><span class="line">    this.componentInstance &#x3D; undefined</span><br><span class="line">    this.parent &#x3D; undefined</span><br><span class="line">    this.raw &#x3D; false</span><br><span class="line">    this.isStatic &#x3D; false</span><br><span class="line">    this.isRootInsert &#x3D; true</span><br><span class="line">    this.isComment &#x3D; false</span><br><span class="line">    this.isCloned &#x3D; false</span><br><span class="line">    this.isOnce &#x3D; false</span><br><span class="line">    this.asyncFactory &#x3D; asyncFactory</span><br><span class="line">    this.asyncMeta &#x3D; undefined</span><br><span class="line">    this.isAsyncPlaceholder &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; DEPRECATED: alias for componentInstance for backwards compat.</span><br><span class="line">  &#x2F;* istanbul ignore next *&#x2F;</span><br><span class="line">  get child (): Component | void &#123;</span><br><span class="line">    return this.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>先解释一下Patch，Patch是Vue VDOM部分中的一个函数，该函数就是<code>Vue.prototype.__patch__</code>，而该函数其实就是在做DIFF，输入是oldVnode、vnode，输出是DIFF后，需要对真实DOM节点所做对DOM操作，比如createElemennt、insertBefore、appendChild等等，而驱动该函数运行的，是Watcher，而Watcher观察的，是data。因此，开发者只需要改变Vue options中的data，就能完成想要的更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;patch.js</span><br><span class="line">function patch (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    &#x2F;&#x2F; 6、输入参数是oldVnode、vnode，就是对oldVnode和vnode做DIFF</span><br><span class="line">    if (isUndef(vnode)) &#123;</span><br><span class="line">      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let isInitialPatch &#x3D; false</span><br><span class="line">    const insertedVnodeQueue &#x3D; []</span><br><span class="line"></span><br><span class="line">    if (isUndef(oldVnode)) &#123;</span><br><span class="line">      &#x2F;&#x2F; empty mount (likely as component), create new root element</span><br><span class="line">      isInitialPatch &#x3D; true</span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const isRealElement &#x3D; isDef(oldVnode.nodeType)</span><br><span class="line">      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        &#x2F;&#x2F; patch existing root node</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 7、开始做DIFF</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (isRealElement) &#123;</span><br><span class="line">          &#x2F;&#x2F; mounting to a real element</span><br><span class="line">          &#x2F;&#x2F; check if this is server-rendered content and if we can perform</span><br><span class="line">          &#x2F;&#x2F; a successful hydration.</span><br><span class="line">          if (oldVnode.nodeType &#x3D;&#x3D;&#x3D; 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating &#x3D; true</span><br><span class="line">          &#125;</span><br><span class="line">          if (isTrue(hydrating)) &#123;</span><br><span class="line">            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, true)</span><br><span class="line">              return oldVnode</span><br><span class="line">            &#125; else if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                &#39;The client-side rendered virtual DOM tree is not matching &#39; +</span><br><span class="line">                &#39;server-rendered content. This is likely caused by incorrect &#39; +</span><br><span class="line">                &#39;HTML markup, for example nesting block-level elements inside &#39; +</span><br><span class="line">                &#39;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#39; +</span><br><span class="line">                &#39;full client-side render.&#39;</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; either not server-rendered, or hydration failed.</span><br><span class="line">          &#x2F;&#x2F; create an empty node and replace it</span><br><span class="line">          oldVnode &#x3D; emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; replacing existing element</span><br><span class="line">        const oldElm &#x3D; oldVnode.elm</span><br><span class="line">        const parentElm &#x3D; nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; create new node</span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          &#x2F;&#x2F; extremely rare edge case: do not insert if old element is in a</span><br><span class="line">          &#x2F;&#x2F; leaving transition. Only happens when combining transition +</span><br><span class="line">          &#x2F;&#x2F; keep-alive + HOCs. (#4590)</span><br><span class="line">          oldElm._leaveCb ? null : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; update parent placeholder node element, recursively</span><br><span class="line">        if (isDef(vnode.parent)) &#123;</span><br><span class="line">          let ancestor &#x3D; vnode.parent</span><br><span class="line">          const patchable &#x3D; isPatchable(vnode)</span><br><span class="line">          while (ancestor) &#123;</span><br><span class="line">            for (let i &#x3D; 0; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm &#x3D; vnode.elm</span><br><span class="line">            if (patchable) &#123;</span><br><span class="line">              for (let i &#x3D; 0; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              &#x2F;&#x2F; #6513</span><br><span class="line">              &#x2F;&#x2F; invoke insert hooks that may have been merged by create hooks.</span><br><span class="line">              &#x2F;&#x2F; e.g. for directives that uses the &quot;inserted&quot; hook.</span><br><span class="line">              const insert &#x3D; ancestor.data.hook.insert</span><br><span class="line">              if (insert.merged) &#123;</span><br><span class="line">                &#x2F;&#x2F; start at index 1 to avoid re-invoking component mounted hook</span><br><span class="line">                for (let i &#x3D; 1; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor &#x3D; ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; destroy old node</span><br><span class="line">        if (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes(parentElm, [oldVnode], 0, 0)</span><br><span class="line">        &#125; else if (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    return vnode.elm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们来看一下patchVnode函数。整个VDOM树，每个节点都有parent和children，而patchVnode其实在做的是：比对oldVnode’s children与vnode’s children</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function patchVnode (</span><br><span class="line">    oldVnode,</span><br><span class="line">    vnode,</span><br><span class="line">    insertedVnodeQueue,</span><br><span class="line">    ownerArray,</span><br><span class="line">    index,</span><br><span class="line">    removeOnly</span><br><span class="line">  ) &#123;</span><br><span class="line">    if (oldVnode &#x3D;&#x3D;&#x3D; vnode) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">      &#x2F;&#x2F; clone reused vnode</span><br><span class="line">      vnode &#x3D; ownerArray[index] &#x3D; cloneVNode(vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const elm &#x3D; vnode.elm &#x3D; oldVnode.elm</span><br><span class="line"></span><br><span class="line">    if (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">      if (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode.isAsyncPlaceholder &#x3D; true</span><br><span class="line">      &#125;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; reuse element for static trees.</span><br><span class="line">    &#x2F;&#x2F; note we only do this if the vnode is cloned -</span><br><span class="line">    &#x2F;&#x2F; if the new node is not cloned it means the render functions have been</span><br><span class="line">    &#x2F;&#x2F; reset by the hot-reload-api and we need to do a proper re-render.</span><br><span class="line">    if (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">      isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">      vnode.key &#x3D;&#x3D;&#x3D; oldVnode.key &amp;&amp;</span><br><span class="line">      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.componentInstance &#x3D; oldVnode.componentInstance</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let i</span><br><span class="line">    const data &#x3D; vnode.data</span><br><span class="line">    if (isDef(data) &amp;&amp; isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const oldCh &#x3D; oldVnode.children</span><br><span class="line">    const ch &#x3D; vnode.children</span><br><span class="line">    if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      for (i &#x3D; 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isUndef(vnode.text)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 8、如果children都存在，则比对children</span><br><span class="line">      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; else if (isDef(ch)) &#123; &#x2F;&#x2F; 9、如果只有vnode上存在children，则这些children都需被add</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          checkDuplicateKeys(ch)</span><br><span class="line">        &#125;</span><br><span class="line">        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)</span><br><span class="line">        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">      &#125; else if (isDef(oldCh)) &#123; &#x2F;&#x2F; 10、如果只有oldVnode上存在children，则这些children都需被删除</span><br><span class="line">        removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">      &#125; else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, &#39;&#39;) &#x2F;&#x2F; 11、针对text 节点做单独处理</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123; &#x2F;&#x2F; 12、针对text节点做单独处理</span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isDef(data)) &#123;</span><br><span class="line">      if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在看updateChildren之前，先看一个函数sameVnode，该函数的用途是，判断节点a和节点b的真实DOM节点是否一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sameVnode (a, b) &#123;</span><br><span class="line">  return (</span><br><span class="line">    a.key &#x3D;&#x3D;&#x3D; b.key &amp;&amp; ( &#x2F;&#x2F; 13、这里会先判断key，因此设置一个合适的key的重要性不言而喻。</span><br><span class="line">    &#x2F;&#x2F; 当前后两次Patch更新时，如果key不变，那么就不会产生不必要的DOM操作</span><br><span class="line">      (</span><br><span class="line">        a.tag &#x3D;&#x3D;&#x3D; b.tag &amp;&amp;</span><br><span class="line">        a.isComment &#x3D;&#x3D;&#x3D; b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) &#x3D;&#x3D;&#x3D; isDef(b.data) &amp;&amp;</span><br><span class="line">        !childrenIgnored(a) &amp;&amp; !childrenIgnored(b) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory &#x3D;&#x3D;&#x3D; b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再看一下updateChildren函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;vdom&#x2F;patch.js</span><br><span class="line">  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    let oldStartIdx &#x3D; 0</span><br><span class="line">    let newStartIdx &#x3D; 0</span><br><span class="line">    let oldEndIdx &#x3D; oldCh.length - 1</span><br><span class="line">    let oldStartVnode &#x3D; oldCh[0]</span><br><span class="line">    let oldEndVnode &#x3D; oldCh[oldEndIdx]</span><br><span class="line">    let newEndIdx &#x3D; newCh.length - 1</span><br><span class="line">    let newStartVnode &#x3D; newCh[0]</span><br><span class="line">    let newEndVnode &#x3D; newCh[newEndIdx]</span><br><span class="line">    let oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">    &#x2F;&#x2F; to ensure removed elements stay in correct relative positions</span><br><span class="line">    &#x2F;&#x2F; during leaving transitions</span><br><span class="line">    const canMove &#x3D; !removeOnly</span><br><span class="line"></span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 14、假设old children是[A, B, C, D]</span><br><span class="line">    &#x2F;&#x2F; new children是[B, C, D]</span><br><span class="line">    &#x2F;&#x2F; 那么，根据下面的循环，DIFF后的DOM操作是 removeChild(A)</span><br><span class="line">    &#x2F;&#x2F; 其实，该函数的最终目的是：在尽量减少DOM操作的前提下，找出old children中能继续使用的真实DOM节点，</span><br><span class="line">    &#x2F;&#x2F; 并保证new children中的节点能够正确的更新</span><br><span class="line">    while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) &#123;</span><br><span class="line">      if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode &#x3D; oldCh[++oldStartIdx] &#x2F;&#x2F; Vnode has been moved left</span><br><span class="line">      &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode &#x3D; oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode &#x3D; newCh[--newEndIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; &#x2F;&#x2F; Vnode moved right</span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        &#x2F;&#x2F; 15、产生DOM操作insertBefore</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode &#x3D; oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode &#x3D; newCh[--newEndIdx]</span><br><span class="line">      &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; &#x2F;&#x2F; Vnode moved left</span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (isUndef(oldKeyToIdx)) oldKeyToIdx &#x3D; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        &#x2F;&#x2F; 16、如果定义了key，则时间复杂度为O(1)，如果没有定义key，则时间复杂度为O(n)</span><br><span class="line">        idxInOld &#x3D; isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        if (isUndef(idxInOld)) &#123; &#x2F;&#x2F; New element</span><br><span class="line">          &#x2F;&#x2F; 17、产生DOM操作appendChild or insertBefore</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          vnodeToMove &#x3D; oldCh[idxInOld]</span><br><span class="line">          if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] &#x3D; undefined</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; same key but different element. treat as new element</span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm &#x3D; isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">      &#x2F;&#x2F; 18、产生DOM操作</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      &#x2F;&#x2F; 19、产生DOM操作</span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结一下整个过程</p>
<ul>
<li>在Vue.prototype._init()中，Watcher将会watch options data等关键位置</li>
<li>开发者代码中更新了options data</li>
<li>Watcher watch到改变，触发updateComponent</li>
<li>调用options中的render函数，生成新vnode</li>
<li>紧接着调用patch，与oldVnode做对比，输出是：需要对真实DOM所做的操作</li>
<li>更新完成</li>
</ul>
</li>
</ul>
<h3 id="Vue-Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）"><a href="#Vue-Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）" class="headerlink" title="Vue Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）"></a>Vue Watcher：相当于大管家，运行时，触发各处的调用（总计18处注释）</h3><ul>
<li><p>上面多次提到了Watcher，Watcher在Vue中的作用有很多，比如</p>
<ul>
<li>上面提到的options data，更新options data触发视图更新</li>
<li>computed特性，更新options data后，更新computed的属性绑定的视图</li>
<li>Vue中手动watch特性</li>
<li>Vuex的实现，也是借助于Watcher</li>
</ul>
</li>
<li><p>整个Watcher其实就是观察者模式，只不过，register是全自动的，不需要开发者关心，我们将重点关注是如何实现全自动register</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;observer&#x2F;watcher.js</span><br><span class="line">export default class Watcher &#123;</span><br><span class="line">  vm: Component; &#x2F;&#x2F; 1、Vue实例</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: Function;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: Array&lt;Dep&gt;;</span><br><span class="line">  newDeps: Array&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?Function;</span><br><span class="line">  getter: Function; &#x2F;&#x2F; 2、当监听到变动是，需要执行到函数</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean &#x2F;&#x2F; 3、mountComponent函数执行时，会new Watcher(xxx)</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.vm &#x3D; vm</span><br><span class="line">    if (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher &#x3D; this</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(this)</span><br><span class="line">    &#x2F;&#x2F; options</span><br><span class="line">    if (options) &#123;</span><br><span class="line">      this.deep &#x3D; !!options.deep</span><br><span class="line">      this.user &#x3D; !!options.user</span><br><span class="line">      this.lazy &#x3D; !!options.lazy</span><br><span class="line">      this.sync &#x3D; !!options.sync</span><br><span class="line">      this.before &#x3D; options.before</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.deep &#x3D; this.user &#x3D; this.lazy &#x3D; this.sync &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    this.cb &#x3D; cb</span><br><span class="line">    this.id &#x3D; ++uid &#x2F;&#x2F; uid for batching</span><br><span class="line">    this.active &#x3D; true</span><br><span class="line">    this.dirty &#x3D; this.lazy &#x2F;&#x2F; for lazy watchers</span><br><span class="line">    this.deps &#x3D; []</span><br><span class="line">    this.newDeps &#x3D; []</span><br><span class="line">    this.depIds &#x3D; new Set()</span><br><span class="line">    this.newDepIds &#x3D; new Set()</span><br><span class="line">    this.expression &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : &#39;&#39;</span><br><span class="line">    &#x2F;&#x2F; parse expression for getter</span><br><span class="line">    if (typeof expOrFn &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      this.getter &#x3D; expOrFn &#x2F;&#x2F; 4、expOrFn即mountComponent函数中到updateComponent函数</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getter &#x3D; parsePath(expOrFn)</span><br><span class="line">      if (!this.getter) &#123;</span><br><span class="line">        this.getter &#x3D; noop</span><br><span class="line">        process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">          &#96;Failed watching path: &quot;$&#123;expOrFn&#125;&quot; &#96; +</span><br><span class="line">          &#39;Watcher only accepts simple dot-delimited paths. &#39; +</span><br><span class="line">          &#39;For full control, use a function instead.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value &#x3D; this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get() &#x2F;&#x2F; 5、在Watcher构造函数中执行get()函数</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Evaluate the getter, and re-collect dependencies.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(this) &#x2F;&#x2F; 6、此处是关键，将会使得 Dep.target &#x3D;&#x3D;&#x3D; this</span><br><span class="line">    let value</span><br><span class="line">    const vm &#x3D; this.vm</span><br><span class="line">    try &#123;</span><br><span class="line">      value &#x3D; this.getter.call(vm, vm) </span><br><span class="line">      &#x2F;&#x2F; 6、第一次执行updateComponent函数，</span><br><span class="line">      &#x2F;&#x2F; updateComponent会依次调用Vue.prototype._render()生成VDOM树、</span><br><span class="line">      &#x2F;&#x2F; Vue.prototype._update()进行patch、patch()、产生DOM操作</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (this.user) &#123;</span><br><span class="line">        handleError(e, vm, &#96;getter for watcher &quot;$&#123;this.expression&#125;&quot;&#96;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">      &#x2F;&#x2F; dependencies for deep watching</span><br><span class="line">      if (this.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      this.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Add a dependency to this directive.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    const id &#x3D; dep.id</span><br><span class="line">    if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">      this.newDepIds.add(id)</span><br><span class="line">      this.newDeps.push(dep)</span><br><span class="line">      if (!this.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(this) &#x2F;&#x2F; 7、向Dep实例中添加 this ，</span><br><span class="line">        &#x2F;&#x2F; 当被defineReactive后的字段（比如data中当字段）被更新，</span><br><span class="line">        &#x2F;&#x2F; Dep类的notify()函数会被调用，紧接着会调用 this.update()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Clean up for dependency collection.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    let i &#x3D; this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      const dep &#x3D; this.deps[i]</span><br><span class="line">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tmp &#x3D; this.depIds</span><br><span class="line">    this.depIds &#x3D; this.newDepIds</span><br><span class="line">    this.newDepIds &#x3D; tmp</span><br><span class="line">    this.newDepIds.clear()</span><br><span class="line">    tmp &#x3D; this.deps</span><br><span class="line">    this.deps &#x3D; this.newDeps</span><br><span class="line">    this.newDeps &#x3D; tmp</span><br><span class="line">    this.newDeps.length &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Subscriber interface.</span><br><span class="line">   * Will be called when a dependency changes.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  update () &#123;</span><br><span class="line">    &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty &#x3D; true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      queueWatcher(this) &#x2F;&#x2F; 8、将Watcher加入队列，</span><br><span class="line">      &#x2F;&#x2F; 这是Vue异步渲染的原理，</span><br><span class="line">      &#x2F;&#x2F; 队列中的Watcher将会在下一个tick中被调用this.run() 函数，</span><br><span class="line">      &#x2F;&#x2F; this.run() 最终会调用 this.getter() 函数，</span><br><span class="line">      &#x2F;&#x2F; 如果 this 是Vue组件实例对应的Watcher，</span><br><span class="line">      &#x2F;&#x2F; 那么，就会触发updateComponent被调用</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Scheduler job interface.</span><br><span class="line">   * Will be called by the scheduler.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  run () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      const value &#x3D; this.get()</span><br><span class="line">      if (</span><br><span class="line">        value !&#x3D;&#x3D; this.value ||</span><br><span class="line">        &#x2F;&#x2F; Deep watchers and watchers on Object&#x2F;Arrays should fire even</span><br><span class="line">        &#x2F;&#x2F; when the value is the same, because the value may</span><br><span class="line">        &#x2F;&#x2F; have mutated.</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        this.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; set new value</span><br><span class="line">        const oldValue &#x3D; this.value</span><br><span class="line">        this.value &#x3D; value</span><br><span class="line">        if (this.user) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            this.cb.call(this.vm, value, oldValue)</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            handleError(e, this.vm, &#96;callback for watcher &quot;$&#123;this.expression&#125;&quot;&#96;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.cb.call(this.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Evaluate the value of the watcher.</span><br><span class="line">   * This only gets called for lazy watchers.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    this.value &#x3D; this.get()</span><br><span class="line">    this.dirty &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Depend on all deps collected by this watcher.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  depend () &#123;</span><br><span class="line">    let i &#x3D; this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      this.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Remove self from all dependencies&#39; subscriber list.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  teardown () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      &#x2F;&#x2F; remove self from vm&#39;s watcher list</span><br><span class="line">      &#x2F;&#x2F; this is a somewhat expensive operation so we skip it</span><br><span class="line">      &#x2F;&#x2F; if the vm is being destroyed.</span><br><span class="line">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(this.vm._watchers, this)</span><br><span class="line">      &#125;</span><br><span class="line">      let i &#x3D; this.deps.length</span><br><span class="line">      while (i--) &#123;</span><br><span class="line">        this.deps[i].removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">      this.active &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>另一个很重要的类是：Dep</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue&#x2F;src&#x2F;core&#x2F;observer&#x2F;dep.js</span><br><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher; &#x2F;&#x2F; 9、这是关键变量：Vue用该全局变量，</span><br><span class="line">  &#x2F;&#x2F; 来保存当前正在watch的Watcher实例是哪个，这是依赖收集的关键</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;; &#x2F;&#x2F; 10、该属性表示所有正在watch该Dep实例的Watcher。</span><br><span class="line">  &#x2F;&#x2F; 一个Dep实例对应了一个data中的一个字段，</span><br><span class="line">  &#x2F;&#x2F; 当该字段被更新，将会触发Watcher运行this.run()</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id &#x3D; uid++</span><br><span class="line">    this.subs &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(this) &#x2F;&#x2F; 11、该方法会调用Dep类的addSub方法，</span><br><span class="line">      &#x2F;&#x2F; 最终的结果是，将Dep.target保存的Watcher实例加入到Dep的subs数组中，</span><br><span class="line">      &#x2F;&#x2F; 后续更新字段触发Dep类的notify时，运行该Watcher实例</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123; &#x2F;&#x2F; 12、当被defineReactive后的字段更新后，notify会被执行</span><br><span class="line">    &#x2F;&#x2F; stabilize the subscriber list first</span><br><span class="line">    const subs &#x3D; this.subs.slice()</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; !config.async) &#123;</span><br><span class="line">      &#x2F;&#x2F; subs aren&#39;t sorted in scheduler if not running async</span><br><span class="line">      &#x2F;&#x2F; we need to sort them now to make sure they fire in correct</span><br><span class="line">      &#x2F;&#x2F; order</span><br><span class="line">      subs.sort((a, b) &#x3D;&gt; a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update() &#x2F;&#x2F;13、执行Watcher实例中的update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; the current target watcher being evaluated.</span><br><span class="line">&#x2F;&#x2F; this is globally unique because there could be only one</span><br><span class="line">&#x2F;&#x2F; watcher being evaluated at any time.</span><br><span class="line">Dep.target &#x3D; null &#x2F;&#x2F; 14、该机制奏效的依据是：同一时刻，</span><br><span class="line">&#x2F;&#x2F; 只会有一个Watcher在运行，而绝大多数情况下Watcher对应的就是Vue组件实例。</span><br><span class="line">&#x2F;&#x2F; Vue的Patch更新机制，是以Vue组件为单位的</span><br><span class="line">const targetStack &#x3D; []</span><br><span class="line"></span><br><span class="line">export function pushTarget (target: ?Watcher) &#123; </span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target &#x3D; target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function popTarget () &#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target &#x3D; targetStack[targetStack.length - 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接下来就是关键方法：defineReactive</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function defineReactive (</span><br><span class="line">  obj: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  val: any,</span><br><span class="line">  customSetter?: ?Function,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const dep &#x3D; new Dep() &#x2F;&#x2F; 15、一个字段key，对应着一个Dep实例</span><br><span class="line"></span><br><span class="line">  const property &#x3D; Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  if (property &amp;&amp; property.configurable &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; cater for pre-defined getter&#x2F;setters</span><br><span class="line">  const getter &#x3D; property &amp;&amp; property.get</span><br><span class="line">  const setter &#x3D; property &amp;&amp; property.set</span><br><span class="line">  if ((!getter || setter) &amp;&amp; arguments.length &#x3D;&#x3D;&#x3D; 2) &#123;</span><br><span class="line">    val &#x3D; obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let childOb &#x3D; !shallow &amp;&amp; observe(val)</span><br><span class="line">  &#x2F;&#x2F; 16、Vue的关键点，使用了Object.defineProperty，</span><br><span class="line">  &#x2F;&#x2F; 借助get&#x2F;set机制，在get时，自动收集依赖，在set时自动触发更新</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">      const value &#x3D; getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123; &#x2F;&#x2F; 17、如果当前有Watcher正在执行，</span><br><span class="line">      &#x2F;&#x2F; 说明该字段key需要进行依赖收集，那么，收集依赖</span><br><span class="line">        dep.depend() </span><br><span class="line">        if (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          if (Array.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">      const value &#x3D; getter ? getter.call(obj) : val</span><br><span class="line">      &#x2F;* eslint-disable no-self-compare *&#x2F;</span><br><span class="line">      if (newVal &#x3D;&#x3D;&#x3D; value || (newVal !&#x3D;&#x3D; newVal &amp;&amp; value !&#x3D;&#x3D; value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;* eslint-enable no-self-compare *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; #7981: for accessor properties without setter</span><br><span class="line">      if (getter &amp;&amp; !setter) return</span><br><span class="line">      if (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val &#x3D; newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb &#x3D; !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify() &#x2F;&#x2F; 18、如果该字段key被更新，运行Watcher</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="从产品角度进行总结"><a href="#从产品角度进行总结" class="headerlink" title="从产品角度进行总结"></a>从产品角度进行总结</h3><p>Vue的成功，有两个亮点可以学习：</p>
<ul>
<li>优化开发者开发体验，拉拢开发者，具体的表现有<ul>
<li>用户只需要写类似html的Vue template模版，入手容易</li>
<li>全自动watch，同时又不降低性能</li>
</ul>
</li>
<li>技术创新<ul>
<li>使用DIFF算法进行Patch更新</li>
<li>全自动Watch的设计</li>
<li>跨平台支持，横向扩大开发者队伍</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code源码解析</title>
    <url>/2020/01/08/get-start-on-vscode/</url>
    <content><![CDATA[<blockquote>
<p>特别声明：本文未经许可禁止转载</p>
</blockquote>
<h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><ul>
<li><code>VS Code</code>是微软在<code>Electron</code>的基础上使用TypeScript开发的</li>
<li>本文是基于VS Code 1.36.0版本的基础上分析的</li>
<li>本文重点解析VS Code工程中，我认为值得学习的地方</li>
<li>如有问题，可以留言</li>
</ul>
<h3 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h3><p>要讲<code>Electron</code>，必须先说<code>Chromium</code>。<code>Chromium</code>使用了多进程架构，分为<code>Browser Process</code>和<code>Render Process</code>，<code>Render Process</code>使用<code>Blink</code>和<code>V8</code>，<code>Blink</code>用于计算布局，<code>V8</code>用于运行<code>JavaScript</code>代码，真正渲染到屏幕上一个一个的像素，是在<code>Browser Process</code>完成的，<code>Browser Process</code>和<code>Render Process</code>通过<code>IPC进程通信</code>（使用Mojo），<code>Browser Process</code>可以保证安全（用于渲染到屏幕，管理Cookie、Storage、网络请求等），而<code>Render Process</code>是在沙箱里面运行的。</p>
<h3 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h3><p><code>Electron</code>在<code>Chromuim</code>基础上，给<code>Browser Process</code>和<code>Render Process</code>都加进了<code>Node Environment</code>，这样，带来了<code>Node</code>开发者，带来了丰富的NPM包，并且，不论是在<code>Browser Process</code>还是<code>Render Process</code>，都能直接调用<code>Node API</code>，从而获得Native能力。同时，<code>Electron</code>还给<code>Browser Process</code>和<code>Render Process</code>加进了<code>Electron API</code>，为开发者提供<code>Browser Process</code>和<code>Render Process</code>的IPC通信API，以及提供一些必要的功能。<br>以下用主进程表示Browser Process，用渲染进程表示Render Process</p>
<h3 id="为方便后文理解，先讲一下VS-Code初始化过程"><a href="#为方便后文理解，先讲一下VS-Code初始化过程" class="headerlink" title="为方便后文理解，先讲一下VS Code初始化过程"></a>为方便后文理解，先讲一下VS Code初始化过程</h3><blockquote>
<p>为方便起见，文件名不加后缀，比如<code>src/main</code>实际为<code>src/main.js</code>，而<code>src/vs/code/electron-main/main</code>实际为<code>src/vs/code/electron-main/main.ts</code></p>
</blockquote>
<ul>
<li>Electron根据根目录下package.json文件中的main字段，在主进程加载<code>src/main</code>，处理本地语言配置以及<code>process.env</code></li>
<li>加载<code>src/vs/code/electron-main/main</code>，实例化<code>CodeMain</code>类，调用该类中的<code>main()</code>方法，创建主进程中外层的<code>InstantiationService</code>,并实例化<code>CodeApplication</code>类，调用该类中的<code>startup()</code>方法<blockquote>
<p><code>InstantiationService</code>用于实例化其他类，使得其他类在主进程或者渲染进程中，在保持单例的同时又能很方便的作为构造器参数传入，这个类是VS Code工程中实现依赖注入的重要部分</p>
</blockquote>
</li>
<li>在<code>CodeApplication</code>类的<code>startup()</code>方法中，再次创建<code>InstantiationService</code>，该<code>InstantiationService</code>是外层<code>InstantiationService</code>的<code>child</code>，并且如果某个类的实例在当前窗口的<code>InstantiationService</code>中找不到时，会去外层的<code>InstantiationService</code>中查找，然后实例化各个<code>Service</code>类，并最终在<code>src/vs/code/electron-main/window</code>中调用<code>new BrowserWindow(options)</code>，打开窗口，携带处理完毕的配置参数加载渲染进程的代码<code>src/vs/code/electron-browser/workbench/workbench</code></li>
<li>加载<code>src/vs/workbench/electron-browser/main</code>，实例化渲染进程各个<code>Service</code>类放入<code>serviceCollection</code>，然后用<code>serviceCollection</code>去实例化渲染进程的<code>InstantiationService</code></li>
<li>加载后续代码，用TypeScript操作DOM，计算Layout，生成页面</li>
</ul>
<h3 id="用Service划分各个功能的界线"><a href="#用Service划分各个功能的界线" class="headerlink" title="用Service划分各个功能的界线"></a>用Service划分各个功能的界线</h3><p><code>VS Code</code>中有许多<code>Service</code>，有的位于主进程，有的位于渲染进程，有的只在主进程使用，有的只在渲染进程使用，有的在主进程中定义逻辑，在渲染进程中通过Electron提供的IPC建立Proxy使用（对于<code>Service</code>使用者来说无感知），<code>Service</code>位于<code>src/vs/platform</code>目录，主要有<code>IInstantiationService</code>,<code>IEnvironmentService</code>,<code>IFileService</code>,<code>ILayoutService</code>,<code>INotificationService</code>,<code>IOpenerService</code>,<code>IStorageService</code>,<code>IWindowsService</code>,<code>IWindowsMainService</code>,<code>IWorkspacesService</code>,<code>IWorkspacesMainService</code>等</p>
<h4 id="依赖注入Dependency-Injection"><a href="#依赖注入Dependency-Injection" class="headerlink" title="依赖注入Dependency Injection"></a>依赖注入Dependency Injection</h4><p>关于依赖注入的整体介绍，VS Code wiki已经讲的很清楚了:</p>
<blockquote>
<p>The code is organized around services of which most are defined in the <code>platform</code> layer. Services get to its clients via <code>constructor injection</code>.<br>A service definition is two parts: (1) the interface of a service, and (2) a service identifier - the latter is required because TypeScript doesn’t use nominal but structural typing. A service identifier is a decoration (as proposed for ES7) and should have the same name as the service interface.<br>Declaring a service dependency happens by adding a corresponding decoration to a constructor argument. In the snippet below <code>@IModelService</code> is the service identifier decoration and <code>IModelService</code> is the (optional) type annotation for this argument. When a dependency is optional, use the <code>@optional</code> decoration otherwise the instantiation service throws an error.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Client &#123;</span><br><span class="line">  constructor(</span><br><span class="line">    @IModelService modelService: IModelService, </span><br><span class="line">    @optional(IEditorService) editorService: IEditorService</span><br><span class="line">  ) &#123;</span><br><span class="line">    &#x2F;&#x2F; use services</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use the instantiation service to create instances for service consumers, like so <code>instantiationService.createInstance(Client)</code>. Usually, this is done for you when being registered as a contribution, like a Viewlet or Language.</p>
</blockquote>
<p>下面从代码角度说明一下：</p>
<ul>
<li>使用<code>decoration</code>（注解）将依赖以变量的形式存到<code>Class</code>上<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;vs&#x2F;platform&#x2F;instantiation&#x2F;common&#x2F;instantiation.ts</span><br><span class="line">export function createDecorator&lt;T&gt;(serviceId: string): ServiceIdentifier&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	if (_util.serviceIds.has(serviceId)) &#123;</span><br><span class="line">		return _util.serviceIds.get(serviceId)!;</span><br><span class="line">	&#125;</span><br><span class="line">    &#x2F;&#x2F;根据TypeScript的规定，实现注解函数</span><br><span class="line">	const id &#x3D; &lt;any&gt;function (target: Function, key: string, index: number): any &#123;</span><br><span class="line">		if (arguments.length !&#x3D;&#x3D; 3) &#123;</span><br><span class="line">			throw new Error(&#39;@IServiceName-decorator can only be used to decorate a parameter&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">		storeServiceDependency(id, target, index, false);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	id.toString &#x3D; () &#x3D;&gt; serviceId;</span><br><span class="line"></span><br><span class="line">	_util.serviceIds.set(serviceId, id);</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function storeServiceDependency(id: Function, target: Function, index: number, optional: boolean): void &#123;</span><br><span class="line">    &#x2F;&#x2F; 在运行时，将注解保存到target（Class），方便之后计算graph</span><br><span class="line">	if (target[_util.DI_TARGET] &#x3D;&#x3D;&#x3D; target) &#123;</span><br><span class="line">		target[_util.DI_DEPENDENCIES].push(&#123; id, index, optional &#125;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		target[_util.DI_DEPENDENCIES] &#x3D; [&#123; id, index, optional &#125;];</span><br><span class="line">		target[_util.DI_TARGET] &#x3D; target;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>根据已有信息计算依赖，构造有向图</li>
<li>找出出度为0的节点，并从这些节点开始，用<code>instantiationService.createInstance(Client)</code>初始化实例<pre class=mermaid>
graph LR;
  Class-A-->Dependence-Class-B;
  Dependence-Class-B-->Dependence-Class-C;
  Class-A-->Dependence-Class-D;
  Dependence-Class-D-->Dependence-Class-E;
  Dependence-Class-D-->Dependence-Class-F;
</pre>
<blockquote>
<p>其中，Class-A为当前需要实例化的类，graph生成完毕之后，根据规则，先实例化Dependence-Class-C、Dependence-Class-E、Dependence-Class-F，再实例化Dependence-Class-B、Dependence-Class-D，最后才实例化Class-A</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; src&#x2F;vs&#x2F;platform&#x2F;instantiation&#x2F;common&#x2F;instantiationService.ts</span><br><span class="line">private _createAndCacheServiceInstance&lt;T&gt;(id: ServiceIdentifier&lt;T&gt;, desc: SyncDescriptor&lt;T&gt;, _trace: Trace): T &#123;</span><br><span class="line">		type Triple &#x3D; &#123; id: ServiceIdentifier&lt;any&gt;, desc: SyncDescriptor&lt;any&gt;, _trace: Trace &#125;;</span><br><span class="line">        &#x2F;&#x2F; 有向图，保存出度和入度</span><br><span class="line">		const graph &#x3D; new Graph&lt;Triple&gt;(data &#x3D;&gt; data.id.toString());</span><br><span class="line"></span><br><span class="line">		function throwCycleError() &#123;</span><br><span class="line">			const err &#x3D; new Error(&#39;[createInstance] cyclic dependency between services&#39;);</span><br><span class="line">			err.message &#x3D; graph.toString();</span><br><span class="line">			throw err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		let count &#x3D; 0;</span><br><span class="line">		const stack &#x3D; [&#123; id, desc, _trace &#125;];</span><br><span class="line">		while (stack.length) &#123;</span><br><span class="line">			const item &#x3D; stack.pop()!;</span><br><span class="line">			graph.lookupOrInsertNode(item);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; TODO@joh use the graph to find a cycle</span><br><span class="line">			&#x2F;&#x2F; a weak heuristic for cycle checks</span><br><span class="line">			if (count++ &gt; 100) &#123;</span><br><span class="line">				throwCycleError();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; check all dependencies for existence and if they need to be created first</span><br><span class="line">			let dependencies &#x3D; _util.getServiceDependencies(item.desc.ctor);</span><br><span class="line">			for (let dependency of dependencies) &#123;</span><br><span class="line"></span><br><span class="line">				let instanceOrDesc &#x3D; this._getServiceInstanceOrDescriptor(dependency.id);</span><br><span class="line">				if (!instanceOrDesc &amp;&amp; !dependency.optional) &#123;</span><br><span class="line">					console.warn(&#96;[createInstance] $&#123;id&#125; depends on $&#123;dependency.id&#125; which is NOT registered.&#96;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (instanceOrDesc instanceof SyncDescriptor) &#123;</span><br><span class="line">					const d &#x3D; &#123; id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) &#125;;</span><br><span class="line">                    &#x2F;&#x2F; 从item节点指向d节点</span><br><span class="line">					graph.insertEdge(item, d);</span><br><span class="line">					stack.push(d);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找出出度为0的节点</span><br><span class="line">			let roots &#x3D; graph.roots();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; if there is no more roots but still</span><br><span class="line">			&#x2F;&#x2F; nodes in the graph we have a cycle</span><br><span class="line">			if (roots.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">				if (!graph.isEmpty()) &#123;</span><br><span class="line">					throwCycleError();</span><br><span class="line">				&#125;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (let &#123; data &#125; of roots) &#123;</span><br><span class="line">				&#x2F;&#x2F; create instance and overwrite the service collections</span><br><span class="line">				const instance &#x3D; this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);</span><br><span class="line">				this._setServiceInstance(data.id, instance);</span><br><span class="line">				graph.removeNode(data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return &lt;T&gt;this._getServiceInstanceOrDescriptor(id);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>值得说明的是，实例化是支持懒加载的，懒加载使用代理模式，懒加载的实现原理如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private _createServiceInstance&lt;T&gt;(ctor: any, args: any[] &#x3D; [], _supportsDelayedInstantiation: boolean, _trace: Trace): T &#123;</span><br><span class="line">		if (!_supportsDelayedInstantiation || !_canUseProxy) &#123;</span><br><span class="line">			&#x2F;&#x2F; eager instantiation or no support JS proxies (e.g. IE11)</span><br><span class="line">			return this._createInstance(ctor, args, _trace);</span><br><span class="line"></span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			&#x2F;&#x2F; Return a proxy object that&#39;s backed by an idle value. That</span><br><span class="line">			&#x2F;&#x2F; strategy is to instantiate services in our idle time or when actually</span><br><span class="line">			&#x2F;&#x2F; needed but not when injected into a consumer</span><br><span class="line">			const idle &#x3D; new IdleValue(() &#x3D;&gt; this._createInstance&lt;T&gt;(ctor, args, _trace));</span><br><span class="line">			return &lt;T&gt;new Proxy(Object.create(null), &#123;</span><br><span class="line">				get(_target: T, prop: PropertyKey): any &#123;</span><br><span class="line">					return idle.getValue()[prop];</span><br><span class="line">				&#125;,</span><br><span class="line">				set(_target: T, p: PropertyKey, value: any): boolean &#123;</span><br><span class="line">					idle.getValue()[p] &#x3D; value;</span><br><span class="line">					return true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Part"><a href="#Part" class="headerlink" title="Part"></a>Part</h3><p>打开VS Code并新建一个窗口（默认配置下），可以将窗口分成几大部分：</p>
<ul>
<li>TitleBarPart，位于顶部</li>
<li>ActivityBarPart，位于最左侧，大部分由Icon构成</li>
<li>SideBarPart，紧贴ActiviyBarPart右侧</li>
<li>EditorPart，编辑器</li>
<li>PanelPart，位于编辑器下面，由Terminal等构成</li>
<li>StatusBarPart，位于最下面，显示状态、分支等<br>可见，VS Code视图由Part构成。<code>Part</code>是VS Code工程中的一个基础类，定义了许多抽象方法，其中，<code>protected createContentArea(parent: HTMLElement, options?: object): HTMLElement | null</code>方法，使用TypeScript操作DOM来用来定义视图</li>
</ul>
<h4 id="Part之用TypeScript操作DOM"><a href="#Part之用TypeScript操作DOM" class="headerlink" title="Part之用TypeScript操作DOM"></a>Part之用TypeScript操作DOM</h4><p>在<code>src/vs/base/browser/ui</code>目录下，定义了许多基础的组件，比如<code>SelectBox</code>,用<code>dom.append(container, $(&#39;.option-text&#39;));</code>形式和CSS，定义界面。</p>
<h3 id="Command机制"><a href="#Command机制" class="headerlink" title="Command机制"></a>Command机制</h3><p>Command可以说是VS Code定义的另一个非常好用的概念。他可以让用户通过<code>Shift+Command+P</code>选择Command然后执行，并且赋予了<code>VS Code Extension</code>扩展Command的能力。Command支持插件进程和VS Code进程相互调用。</p>
<h3 id="Extension（插件）机制"><a href="#Extension（插件）机制" class="headerlink" title="Extension（插件）机制"></a>Extension（插件）机制</h3><p>软件开发中的开闭原则：开放扩展，关闭修改。Extension便是开闭原则的一个很好的实现。Chrome有插件，Cocos有插件，Hexo有插件，Webpack有插件，Gulp有插件，VS Code也有插件</p>
<p>VS Code内置插件在<code>extension</code>目录下，内置插件分成两种，一种是本地内置插件，另一种是打包是从Extension Markets下载的内置插件，插件开发文档<a href="https://code.visualstudio.com/api" target="_blank" rel="noopener">点这</a>。从插件大类来看，也可以分成两种，一种是<code>Normal Extension</code>，可以使用VS Code API，另一种是<code>Debugger Extension</code>，用于运行Debug Adapter。</p>
<h3 id="Gulp编译打包"><a href="#Gulp编译打包" class="headerlink" title="Gulp编译打包"></a>Gulp编译打包</h3><p>Gulp官方介绍如下：</p>
<blockquote>
<ul>
<li>Automation - gulp is a toolkit that helps you automate painful or time-consuming tasks in your development workflow.</li>
<li>Platform-agnostic - Integrations are built into all major IDEs and people are using gulp with PHP, .NET, Node.js, Java, and other platforms.</li>
<li>Strong Ecosystem - Use npm modules to do anything you want + over 2000 curated plugins for streaming file transformations</li>
<li>Simple - By providing only a minimal API surface, gulp is easy to learn and simple to use</li>
</ul>
</blockquote>
<p>VS Code打包脚本位于<code>build</code>目录下，在执行<code>gulp watch</code>之后，gulp会首先加载根目录的<code>gulpfile.js</code>文件，进而加载<code>build</code>目录下一系列<code>gulp.*.js</code>文件，<code>build/gulp.*.js</code>文件中定义了许多<code>gulp task</code>，各个task可以相互依赖。如果想运行VS Code，可以参考[官方文档](<a href="https://github.com/microsoft/VS" target="_blank" rel="noopener">https://github.com/microsoft/VS</a> Code/wiki/How-to-Contribute)。</p>
<h3 id="VS-Code调试架构"><a href="#VS-Code调试架构" class="headerlink" title="VS Code调试架构"></a>VS Code调试架构</h3><p>VS Code可以调试<code>javascript</code>、<code>python</code>、<code>php</code>、<code>c</code>各种语言，而实现这些调试等基础就是<code>DAP</code>协议，官方对<code>DAP</code>的图示如下：</p>
<p><img src="/images/debug-arch1.png" alt="dap"></p>
<p>VS Code 定义了一种抽象的协议即DAP，并实现了一种通用的调试UI，VS Code使用该协议与各种语言的调试进程通信，但是，各种语言不会实现DAP协议，因此，需要一个Adapter，即<code>Debug Adapter（DA）</code>，DA运行在一个单独的进程里面，与调试进程通信。<br>如果你想调试某种语言，首先，需要先实现该语言的<code>Debug Adapter</code>并以<code>Debugger Extension</code>的形式，安装到VS Code上，关于如何实现，你可以查看<a href="https://code.visualstudio.com/api/extension-guides/debugger-extension" target="_blank" rel="noopener">官方文档</a>。当然，大部分语言的<code>Debug Adapter</code>都已经被实现，你可以直接使用。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle</a><br><a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/decorators.html</a><br><a href="https://github.com/microsoft/vscode/wiki/Source-Code-Organization" target="_blank" rel="noopener">https://github.com/microsoft/vscode/wiki/Source-Code-Organization</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a><br><a href="https://code.visualstudio.com/api/extension-guides/debugger-extension" target="_blank" rel="noopener">https://code.visualstudio.com/api/extension-guides/debugger-extension</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样选择并学习一个开源项目</title>
    <url>/2020/01/07/how-to-learn-a-project/</url>
    <content><![CDATA[<h3 id="怎样选择一个开源项目去学习"><a href="#怎样选择一个开源项目去学习" class="headerlink" title="怎样选择一个开源项目去学习"></a>怎样选择一个开源项目去学习</h3><ul>
<li>文档要丰富，包括user guide，document api，从clone到运行环境配置，debug</li>
<li>有测试用例，如果一个项目没有测试用例，那么这个项目最好不要去看</li>
<li>blog post丰富</li>
<li>有需求，能用得上，如果用不上，很快就忘记了</li>
</ul>
<h3 id="怎样学习一个开源项目"><a href="#怎样学习一个开源项目" class="headerlink" title="怎样学习一个开源项目"></a>怎样学习一个开源项目</h3><ul>
<li>首先，网速要快。由于众所周知的原因，我们需要一个工具，跨过山和大海，推荐<code>clashx/clash</code></li>
<li>详细阅读项目文档，design document等，如果是英文，最好直接自己阅读英文，而不是看别人已经翻译好的</li>
<li>不要使用windows，选择mac或者linux</li>
<li>配置好运行环境，能够debug，能够使用代码跳转，mac上推荐<code>vscode</code></li>
<li>从sample开始，然后是测试用例，一点一点分解</li>
<li>如果改项目支持插件开发，则一定要去完整的看一遍插件开发流程，并尝试开发一个插件</li>
</ul>
]]></content>
      <categories>
        <category>方法</category>
      </categories>
      <tags>
        <tag>姿势</tag>
      </tags>
  </entry>
</search>
